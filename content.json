{"pages":[{"title":"关于作者,自娱自乐","text":"英文名 Meone 中文名: 松松 籍贯: 贵州 • 遵义 (历史名城、遵义会议) 呵呵哒: 差点没去上大学,打砖 从事: iOS开发，钻研技术 邮箱: xusong1313@gmail.com | yutiya@qq.com QQ: 827447417 自述: 喜欢妹纸 喜欢技术 攻城狮 喜欢Markdown语法(Begin Blog Blog Blog) 喜欢一切新奇的科学技术，就是这么6 github重度痴迷 喜欢各种语言，擅长各种Hello World! 谢谢 @ppoffice的主题","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"C语言const","text":"C语言const用法const是一个C语言的关键字,它限定一个变量不允许被改变,产生静态作用.常类型是指使用类型修饰符const说明的类型,常类型的变量的值是不能改变的.(可以采取别的方式修改值) 下面的代码错在哪里？ 12const int n = 5;int a[n]; 为什么编译器会报错,”常量”和”只读变量”是有区别的.常量,例如5,”abc”等等,肯定是只读的,常量被编译器放在只读区域,当然也就不能修改.而”只读变量”则是在内存中开辟一个地方来存放它的值,只不过这个值被编译器限定不允许修改. 下面的代码哪一句有错误? 123456typedef char *pStr;char string[4] = &quot;bbc&quot;;const char *p1 = &quot;str&quot;;const char p2 = &quot;str&quot;;p1++;p2++; 答案是p2++错误. const的基本使用形式: const type m; 限定m不可变,只读. 可以对应*p1不可变,p1可变.p2不可变 指针举例下面的const分别修饰什么 const在前面 123const int a; //a不可变const char *p; //*p不可变,p可变const char * const p; //*p不可变,p可变 const在类型后面 1234int const a; //a不可变char const *p; //*p不可变,p可变char * const p; //p不可变,*p可变char const * const * p; //*p不可变,p不可变 分析:const值修饰其后的变量,放在类型前和类型后,并没有区别,*不是类型,*只是代表改变量是前面的修饰数据类型的指针 多变量一起声明 1int const *p1, p2; p2是const,*和p1是一个整体,*p1不可变,p1可变.仅声明了p1为指向int类型的指针.如果两者皆为指向int类型的指针,int *p1, *p2即可. 1int const * const p1, p2; p2是const,*p1是const,被前一个修饰、p1被后一个修饰,也是const 1int * const p1, p2; p1是const,(* const p1)才是一个整体,所以p2是这样的int p2","link":"/2015/09/02/C语言const/"},{"title":"C语言变态的HelloWorld","text":"C语言变态的HelloWorldC语言真是世界上最难的语言,所以C++是最恐怖的语言 第一种实现方式,使用宏定义123456789101112// file main.c#define _________ }#define ________ putchar#define _______ main#define _(a) ________(a);#define ______ _______(){#define __ ______ _(0x48)_(0x65)_(0x6C)_(0x6C)#define ___ _(0x6F)_(0x2C)_(0x20)_(0x77)_(0x6F)#define ____ _(0x72)_(0x6C)_(0x64)_(0x21)#define _____ __ ___ ____ _________#include &lt;stdio.h&gt;_____ 看一下该代码经过预处理之后是什么样子,使用$ gcc -E main.c -o main.i 12// file main.i 看最后的部分,main函数main(){ putchar(0x48);putchar(0x65);putchar(0x6C);putchar(0x6C); putchar(0x6F);putchar(0x2C);putchar(0x20);putchar(0x77);putchar(0x6F); putchar(0x72);putchar(0x6C);putchar(0x64);putchar(0x21); } 现在我们来解析这段代码,一步一步看 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt; //这句之前的都是宏定义,之后的代码在预编译阶段会进行宏替换_____ &gt;&gt;&gt;&gt; __ ___ ____ _________ -- 先看来第一个 __ &gt;&gt;&gt;&gt; ______ _(0x48)_(0x65)_(0x6C)_(0x6C) &gt;&gt;&gt;&gt; _______(){ _(0x48)_(0x65)_(0x6C)_(0x6C) &gt;&gt;&gt;&gt; main(){ putchar(0x48);putchar(0x65);putchar(0x6C);putchar(0x6C); -- 继续 ___ &gt;&gt;&gt;&gt; _(0x6F)_(0x2C)_(0x20)_(0x77)_(0x6F) &gt;&gt;&gt;&gt; putchar(0x6F);putchar(0x2C);putchar(0x20);putchar(0x77);putchar(0x6F); -- 继续 ____ &gt;&gt;&gt;&gt; _(0x72)_(0x6C)_(0x64)_(0x21) &gt;&gt;&gt;&gt; putchar(0x72);putchar(0x6C);putchar(0x64);putchar(0x21); -- 最后 _________ &gt;&gt;&gt;&gt; } 由四部分组成,所以得到了上面的那段代码 0x全是16进制数,以ASCII码形式转换成字符,前面是零,不是&apos;鸥&apos; 0x48 &gt; 72 == H 0x65 &gt; 101 == e 0x6c &gt; 108 == l 0x6f &gt; 111 == o 0x2c &gt; 44 == , 0x20 &gt; 32 == Space(空格) 0x77 &gt; 119 == w 0x72 &gt; 114 == r 0x64 &gt; 100 == d 0x21 &gt; 33 == ! 输出结果Hello, world!,你的呢?测试了吗?此乃没有写返回值类型的main函数噢好了,就分析这一个,剩下的贴代码,太丧心病狂了 第二种,数组123456789#include&lt;stdio.h&gt;main(){ int x=0,y[14],*z=&amp;y;*(z++)=0x48;*(z++)=y[x++]+0x1D; *(z++)=y[x++]+0x07;*(z++)=y[x++]+0x00;*(z++)=y[x++]+0x03; *(z++)=y[x++]-0x43;*(z++)=y[x++]-0x0C;*(z++)=y[x++]+0x57; *(z++)=y[x++]-0x08;*(z++)=y[x++]+0x03;*(z++)=y[x++]-0x06; *(z++)=y[x++]-0x08;*(z++)=y[x++]-0x43;*(z++)=y[x]-0x21; x=*(--z);while(y[x]!=NULL)putchar(y[x++]);} 第三种,goto子句1234567891011121314 #include&lt;stdio.h&gt;#define __(a) goto a;#define ___(a) putchar(a);#define _(a,b) ___(a) __(b);main(){ _:__(t)a:_(&apos;r&apos;,g)b:_(&apos;$&apos;,p) c:_(&apos;l&apos;,f)d:_(&apos; &apos;,s)e:_(&apos;a&apos;,s) f:_(&apos;o&apos;,q)g:_(&apos;l&apos;,h)h:_(&apos;d&apos;,n) i:_(&apos;e&apos;,w)j:_(&apos;e&apos;,x)k:_(&apos;\\n&apos;,z) l:_(&apos;H&apos;,l)m:_(&apos;X&apos;,i)n:_(&apos;!&apos;,k) o:_(&apos;z&apos;,q)p:_(&apos;q&apos;,b)q:_(&apos;,&apos;,d) r:_(&apos;i&apos;,l)s:_(&apos;w&apos;,v)t:_(&apos;H&apos;,j) u:_(&apos;a&apos;,a)v:_(&apos;o&apos;,a)w:_(&apos;)&apos;,k) x:_(&apos;l&apos;,c)y:_(&apos;\\t&apos;,g)z:___(0x0)} 第四种,调用main函数,好牛123456789int n[]={0x48,0x65,0x6C,0x6C,0x6F,0x2C,0x20,0x77,0x6F,0x72,0x6C,0x64,0x21,0x0A,0x00},*m=n;main(n){putchar(*m)!=&apos;\\0&apos;?main(m++):exit(n++);} 第五种,位运算12345678910111213141516171819202122232425262728main(){int i,n[]={(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))), (((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+ (1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))- ((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),(((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-(1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))),((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-(1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-(1&lt;&lt;(1&gt;&gt;1))), (((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))- ((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))+(1&lt;&lt;1)), (((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1))-((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;(1&gt;&gt;1)))-((1&lt;&lt;1) &lt;&lt;(1&lt;&lt; (1&gt;&gt;1)))),(((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt; (1&lt;&lt;1))- ((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;(1&gt;&gt;1)))), (((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1) &lt;&lt;(1&lt;&lt;1))+(1&lt;&lt;(1&gt;&gt;1))),(((1&lt;&lt;1)&lt;&lt;(1&lt;&lt;1))+((1&lt;&lt;1)&lt;&lt; (1&lt;&lt;(1&gt;&gt;1))) + (1&lt;&lt; (1&gt;&gt;1)))}; for(i=(1&gt;&gt;1);i&lt;(((1&lt;&lt;1) &lt;&lt;(1&lt;&lt;1))+((1 &lt;&lt;1)&lt;&lt; (1&lt;&lt;(1&gt;&gt;1))) + (1&lt;&lt;1)); i++) printf(&quot;%c&quot;,n[i]); } 第六种,得使用g++编译,疯狂的自增12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#define _(_) putchar(_);int main(void){int i = 0;_(++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++i)_(++++++++++++++++++++++++++++++++++++++++++++++++++++++++++i)_(++++++++++++++i)_(--++i)_(++++++i)_(--------------------------------------------------------------------------------------------------------------------------------------i)_(------------------------i)_(++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++i)_(----------------i)_(++++++i)_(------------i)_(----------------i)_(--------------------------------------------------------------------------------------------------------------------------------------i)_(----------------------------------------------i)return i;}","link":"/2015/08/06/C语言变态的HelloWorld/"},{"title":"C语言数组名","text":"C语言数组名 a和&amp;a的本质 从二维数组角度分析 从指针运算角度分析 a和&amp;a的本质C语言数组名是一个特殊的东西 int a[5] = {1, 2, 3, 4, 5} a &amp;a &amp;a[0]这三个的值是相等的 a是数组名,值是数组首元素的地址.数组名是一个指针常量,能用于指针运算但是有两种情况比较特殊: 使用sizeof操作符,结果为整个数组的长度 使用&amp;取地址操作时,得到一个数组指针 &amp;a这才是一个数组指针,值是数组的地址 注意: &amp;a和a的值相等,但是*&amp;a和*a的值不相等.说明*&amp;a是对这个数组指针进行了取值操作,取得的是数组首元素的地址,还是一个指针,而不是对&amp;a的值所代表的内存地址进行取值.这应该是C语言对数组指针运算的特殊规定.*a就不言而喻是数组首元素的值 123456789101112131415#include &lt;stdio.h&gt;int main(int argc, const char * argv[]){ int a[5]={1,2,3,4,5}; printf(&quot;a = %x\\n&quot;,a); //数组名 值相等而已 printf(&quot;&amp;a = %x\\n&quot;,&amp;a); //数组地址 printf(&quot;sizeof a = %d\\n&quot;, sizeof(a)); //数组长度 printf(&quot;*(int*)&amp;a = %x\\n&quot;,(*((int *)(&amp;a)))); //取得数组第一个元素的值 printf(&quot;*&amp;a = %x\\n&quot;, *(&amp;a)); // 还是一个指针,值为数组首元素的地址 printf(&quot;**&amp;a = %x\\n&quot;,(*(*(&amp;a)))); //数组第一个元素的值 printf(&quot;&amp;a[0] = %x\\n&quot;,&amp;a[0]); //数组第一个元素的地址 printf(&quot;*&amp;a[0] = %x\\n&quot;,*(&amp;a[0])); //数组第一个元素的值 printf(&quot;*a = %x&quot;, *a); //数组第一哥元素的值 return 0;} 结果: 123456789a = 5fbff780&amp;a = 5fbff780sizeof a = 20*(int*)&amp;a = 1*&amp;a = 5fbff780**&amp;a = 1&amp;a[0] = 5fbff780*&amp;a[0] = 1*a = 1 二维数组在二维数组中,数组名a是第一个一维数组的数组指针理解完下面这段代码,就能轻松使用指针运算来获取二维数组的值了 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, const char * argv[]){ int a[3][3] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; int i = 0; int j = 0; printf(&quot;a = %x \\n&quot;, a); //第一个一维数组的数组指针 printf(&quot;*a = %x \\n&quot;, *a); //第一个一维数组的首地址 printf(&quot;**a = %d \\n&quot;, **a); //第一个一维数组中第一个元素的值 printf(&quot;(a+1) = %x \\n&quot;, (a+1)); //第二个一维数组的数组指针 printf(&quot;*(a+1) = %x \\n&quot;, *(a+1)); //第二个一维数组的首地址 for(i=0; i&lt;3; i++) { for(j=0; j&lt;3; j++) { printf(&quot;%d\\n&quot;, *(*(a+i) + j)); //通过指针运算获取值 } } return 0;}","link":"/2015/09/02/C语言数组名/"},{"title":"FFmpeg-iOS环境下编译","text":"FFmpeg-iOS环境下编译 第一步下载安装yasm github地址 download 1234tar xzvf yasm-1.3.0.tar.gz 解压cd yasm-1.3.0 进入目录./autogen.sh 自动生成make &amp;&amp; make install 编译安装 第二步下载gas-preprocessor github地址 download 123unzip gas-preprocessor-master.zip 解压cd gas-preprocessor-master 进入目录sudo cp gas-preprocessor.pl /usr/bin/gas-preprocessor.pl 复制 第三步下载FFmpeg-iOS-build-script github地址 download 123unzip FFmpeg-iOS-build-script-master.zip 解压cd FFmpeg-iOS-build-script-master 进入目录./build-ffmpeg.sh 自动下载FFmpeg编译 当前一顿操作后，我发现，其实直接下载进行第三步，然后执行./build-ffmpeg.sh，脚本会执行安装 Homebrew yasm gas-preprocessor.pl","link":"/2018/11/30/FFmpeg-iOS环境下编译-md/"},{"title":"Java Socket中的ObjectOutputStream和ObjectInputStream","text":"Java Socket中的ObjectOutputStream和ObjectInputStream 在写Socket通讯程序时出现的bug获取socket对象的InputStream和OutputStream封装为ObjectInputStream和ObjectOutputStream,启动Server和Client发送序列化的对象会发现Client和Server连上了,但是一直没有传输数据后来发现问题如果Server端首先建立的是ObjectInputStream = new ObjectInputStream(socket.getInputStream());那么Client绝对不能先建立 ObjectInputStream 后建立ObjectOutputStream否则程序会一直阻塞…列出所有情况,只限封装为Object流的情况其他的三种情况都是可以的(Server : 1st Output 2nd Input Client :1st Output 2nd Input) &lt;&lt;—-允许(Server : 1st Output 2nd Input Client :1st Input 2nd Output) &lt;&lt;—-允许(Server : 1st Input 2nd Output Client :1st Output 2nd Input) &lt;&lt;—-允许(Server : 1st Input 2nd Output Client :1st Input 2nd Output) &lt;&lt;—-只有这种情况不允许 备注:使用不带缓冲区的流,直接写就好了,带缓冲区的,先刷一刷flush","link":"/2015/11/17/Java-Socket-Object/"},{"title":"Javascript语法中的一些小陷阱","text":"Javascript语法中的一些小陷阱Javascript对象,其实也就是使用哈希表实现原来这样写创建出来的obj是一个对象在Javascript中没有map噢(也就是在别的语言中常常使用的键值对) 1234var obj = { username: &apos;yutiya&apos;, age: 18 }; 直接打印上面创建的对象,会打印出在Node.js中还不会打印出前面的Object 123console.log(obj);结果 &gt;&gt;&gt; : Object {username: &quot;yutiya&quot;, age: 18} 如果这样呢?因为它真的是Javascript对象,我也是现在才知道,不晚! 123console.log(&apos;obj:&apos; + obj);结果 &gt;&gt;&gt; : obj:[object Object] Javascript对象是不是和JSON很像下面来一段标准的JSON字符串,楼主也是傻逼了,才想通的,呵呵eval() 函数使用的是 JavaScript 编译器,可解析 JSON 文本然后生成 JavaScript 对象.必须把文本包围在括号中,这样才能避免语法错误: 12345var txt = &apos;{ &quot;employees&quot; : [&apos; + &apos;{ &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; },&apos; + &apos;{ &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; },&apos; + &apos;{ &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ]}&apos;;var jsonT = eval(&apos;(&apos; + txt + &apos;)&apos;); 提示: eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。 使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本,而不会编译脚本。在浏览器中,这提供了原生的 JSON 支持,而且 JSON 解析器的速度更快。较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。 附上一些可用的代码,如果一些古老的浏览器,可以下载json2.js作者没用过,自己上百度谷歌一下,我只给github地址 12JSON.stringify() // 将Javascript对象转换成json格式的字符串JSON.parse() // 将JSON格式的字符串转换成Javascript对象 不过 js 这门渣渣语言本来就乱嘛,什么变量提升（传送门 ）啊,没有 main 函数啊,变量作用域啊,数据类型常常简单得只有数字、字符串、哈希、数组啊, 这一系列的问题,都不是事儿。 作者是菜鸟中的菜鸟,写博客慢慢记录下来!","link":"/2015/07/31/Javascript语法中的一些小陷阱/"},{"title":"NSUrlSession-Study","text":"学习NSUrlSession的使用我的服务器是搭建在本地的,所以可以看到我访问的都是localhost,数据也是写死的 基本使用 123456789// 下面的代码，放进一个按钮点击事件中执行NSURLSession *session = [NSURLSession sharedSession];NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;http://localhost/studing/1.php&quot;]];NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSString *string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, string);}];[task resume]; 打印的内容,就是http请求所返回的所有内容 next,感受异步 123456789101112131415161718//按钮点击- (void)buttonRequestAction:(UIButton *)sender{ NSURLSession *session = [NSURLSession sharedSession]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;http://localhost/studing/1.php&quot;]]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { sleep(3); // 延迟 NSString *string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, string); }]; [task resume]; }// 按钮点击- (void)otherAction:(UIButton *)sender{ NSLog(@&quot;并没有阻塞主线程&quot;);} 点击request请求服务器,再点击另一个按钮的时候,并没有阻塞主线程这就是NSUrlSession的强大之处,next,后面继续","link":"/2015/11/27/NSUrlSession-Study/"},{"title":"Swift和OC混编","text":"Swift和OC混编Swift语言,抱歉,博主会的不多,今天来简单的讲解一下OC与Swift的混编做得不多,我们只要做到能相互调用就好了就做世界上最伟大的程序Hello World 打开Xcode: 来个简单的命令行”Hello World”: 新建一个OC类: YES Xcode自动帮我们创建桥接swift和OC的头文件: 开始写点代码叭: HelloOC.h: 1234567#import &lt;Foundation/Foundation.h&gt;@interface HelloOC : NSObject- (void)sayHelloWorld;@end HelloOC.m: 12345678910#import &quot;HelloOC.h&quot;@implementation HelloOC- (void)sayHelloWorld{ NSLog(@&quot;Hello World!&quot;);}@end OCSwift-Bridging-Header.h: 1#import &quot;HelloOC.h&quot; //在swift文件中调用OC对象,需要导入 main.swift: 1234import Foundationvar hello = HelloOC()hello.sayHelloWorld() 来看看目录结构,运行,没有问题 新建一个Swift类,用于在OC类中调用: HelloSwift.swift: 123456789import Foundationclass HelloSwift: NSObject { func sayHello() { println(&quot;Swift Hello&quot;) }} OC调用swift会生成一个隐藏的头文件,头文件名称为项目名-Swift.h#import &quot;OCSwift-Swift.h&quot;导入 如果在HelloOC.h中导入该头文件会报错 在h文件中改使用@class 类名;引入 HelloOC.h: 123456789101112#import &lt;Foundation/Foundation.h&gt;@class HelloSwift;@interface HelloOC : NSObject{ HelloSwift *swift;}- (void)sayHelloWorld;@end HelloOC.m: 1234567891011121314151617181920#import &quot;HelloOC.h&quot;#import &quot;OCSwift-Swift.h&quot;@implementation HelloOC- (id)init{ if (self = [super init]) { swift = [[HelloSwift alloc] init]; } return self;}- (void)sayHelloWorld{ NSLog(@&quot;Hello World!&quot;); [swift sayHello];}@end 运行,没错,这样混编就搞定了 另外,该桥接的头文件,在这里配置,可以自己创建该头文件并导入 该配置指向该头文件","link":"/2015/10/10/OC与Swift混编/"},{"title":"ReactiveCocoa初体验","text":"Reactive的学习和使用 原文链接:http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1 下载起始项目:start project 删除测试target,用不上,这样项目便不会报错 在xcodeproj同级目录下创建文件Podfile,使用CocoaPods安装Reactive库 Podfile文件内容: 123platform :ios, &apos;7.0&apos;pod &apos;ReactiveCocoa&apos;, &apos;2.1.8&apos; 运行$ pod install 安装完成后使用xcworkspace文件打开项目 在RWViewController.m文件 1#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt; 在viewDidLoad中添加代码 123[self.usernameTextField.rac_textSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x);}]; 现在我们就能体验到信号编程了 可以看到我们每次输出一个字符都会产生一个信号,这大概就是信号编程吧我们看看信号传递流程 现在我们将添加的代码修改一下 123456[[self.usernameTextField.rac_textSignal filter:^BOOL(id value) { NSString *text = value; return text.length &gt; 3;}] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x);}]; 我们可以看到,当满足filter的条件之后,才会产生信号,后面的条件才会继续执行,有一种链式操作的感觉我们将上面的代码的完整结构 12345678RACSignal *usernameSoucesSignal = self.usernameTextField.rac_textSignal;RACSignal *filteredUsername = [usernameSoucesSignal filter:^BOOL(id value) { NSString *text = value; return text.length &gt; 3;}];[filteredUsername subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x);}]; 可以看出来,每次文本框内容的改变就会产生一个信号对象,调用信号处理的block,得到结果很显然,我们更喜欢上面那种简洁的语法 现在让我们更进一步,看看到底发生了写什么: 123456789 [[[self.usernameTextField.rac_textSignal map:^id(id value) { NSString *text = value; return @(text.length);}] filter:^BOOL(id value) { NSNumber *length = value; return [length integerValue] &gt; 3;}] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x);}]; 信号传递流程 我比较笨,假设你跟我一样,并没有发现有什么问题,现在我们再改改代码: 123456789 [[[self.usernameTextField.rac_textSignal map:^id(id value) { NSString *text = value; return text;}] filter:^BOOL(id value) { NSString *text = value; return text.length &gt; 3;}] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x);}]; 这下能看懂了吧,map解析字符串然后向下传递,filter通过返回YES来过滤字符串,subscribeNext得到过滤后的字符串,如果没有满足过滤条件,信号将不会向下传递,能理解信号传递的思路了么 创建验证状态信号 123456789RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(id value) { NSString *text = value; return @([self isValidUsername:text]); }];RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(id value) { NSString *text = value; return @([self isValidPassword:text]);}]; 得到验证信号后,解析然后设置文本框背景与用户交互不过我们不采用下面的写法,使用更好的写法 1234567[[validPasswordSignal map:^id(id value) { NSNumber *passwordValid = value; return [passwordValid boolValue] ? [UIColor clearColor] :[UIColor yellowColor];}] subscribeNext:^(id x) { UIColor *color = x; self.passwordTextField.backgroundColor = color;}]; 我们使用宏定义的方式将解析后返回的信号进行绑定处理 123456789RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(id value) { NSNumber *passwordValid = value; return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];}];RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(id value) { NSNumber *usernameValid = value; return [usernameValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];}]; 可以看到代码,我们将文本框和背景颜色绑定为一个信号处理,当验证信号解析后将自动设置我们来看看通常我们一般这样写 12self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor]; 这个能看懂吧,平常我们是这样写的,只是改变了编程方式,有一种链式操作的感觉,能将信号绑定处理,其实还不错信号传递流程是这样的 组合信号 在viewDidLoad添加代码: 1234567RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid){ return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);}];[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) { self.signInButton.enabled = [signupActive boolValue];}]; 将两个信号组合生成一个新的信号进行解析处理 我们这样修改后,就可以移除下面的这些无用的代码了 12345678910@property (nonatomic) BOOL passwordIsValid;@property (nonatomic) BOOL usernameIsValid;// handle text changes for both text fields[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged];[self.passwordTextField addTarget:self action:@selector(passwordTextFieldChanged) forControlEvents:UIControlEventEditingChanged]; 同时可以移除updateUIState,usernameTextFieldChanged和passwdTextFieldChanged方法等并删除多余的代码现在的信号传递流程是这样的 现在代码是不是更简洁,更方便 下一步,将其余的业务逻辑也使用信号处理 打开Main.storyboard,删除绑定的sign up按钮事件继续在viewDidLoad中添加事件 123[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) { NSLog(@&quot;button clicked&quot;);}]; 可以看到下面的效果,事件也可以绑定为信号,感觉好6 现在我们可以移除signInButtonTouched:事件,并创建信号增加一个方法 12345678910- (RACSignal *)signInSingal{ return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) { [subscriber sendNext:@(success)]; [subscriber sendCompleted]; }]; return nil; }];} 在viewDidLoad中添加代码 12345[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) { return [self signInSingal];}] subscribeNext:^(id x) { NSLog(@&quot;Singal in result %@&quot;, x);}]; 信号传递流程: 下面来修改一下代码: 1234567[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) { return [self signInSingal];}] flattenMap:^RACStream *(id value) { return [self signInSingal];}] subscribeNext:^(id x) { NSLog(@&quot;Sign in result %@&quot;, x);}]; 当点击按钮时验证通过得到1,验证失败得到0现在我们让验证通过得到1时跳转 1234567891011[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) { return [self signInSingal];}] flattenMap:^RACStream *(id value) { return [self signInSingal];}] subscribeNext:^(NSNumber *signedIn) { BOOL success = [signedIn boolValue]; self.signInFailureText.hidden = success; if (success) { [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self]; }}]; 现在,我们就使用ReactiveCocoa替代了原来的业务处理,比较简洁,但是也比较难理解效果图: 修改代码,在信号传递中加一个过程 123456789101112[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(id x) { self.signInButton.enabled = NO; self.signInFailureText.hidden = YES;}] flattenMap:^RACStream *(id value) { return [self signInSingal];}] subscribeNext:^(NSNumber *signedIn) { self.signInButton.enabled = YES; BOOL success = [signedIn boolValue]; if(success) { [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self]; }}]; 再运行看看,细节更加完善","link":"/2015/08/12/ReactiveCocoa初体验/"},{"title":"Redis初试","text":"Redis入门Redis是一款依据BSD开源协议发行的高性能Key-Value存储系统.通常被成为数据结构服务器,因为值可以是字符串(String),哈希(Map),列表(list),集合(sets)和有序集合(sorted sets)等类型. 提供一个英文的在线互动学习地址: http://try.redis.io/ 命令不需要管大小写,但是键大小写是敏感的在redis,和json类似,类似键值对,所以一定要注意理解键key、值value编程的都知道,以0开始,所以别被忽悠了先列出常用命令 12345678DECR, DECRBY, DEL, EXISTS, EXPIRE, GET, GETSET, HDEL, HEXISTS, HGET, HGETALL, HINCRBY, HKEYS, HLEN, HMGET, HMSET, HSET, HVALS, INCR, INCRBY, KEYS, LINDEX, LLEN, LPOP, LPUSH, LRANGE, LREM, LSET, LTRIM, MGET, MSET, MSETNX, MULTI, PEXPIRE, RENAME, RENAMENX, RPOP, RPOPLPUSH, RPUSH, SADD, SCARD, SDIFF, SDIFFSTORE, SET, SETEX, SETNX, SINTER, SINTERSTORE, SISMEMBER, SMEMBERS, SMOVE, SORT, SPOP, SRANDMEMBER, SREM, SUNION, SUNIONSTORE, TTL, TYPE, ZADD, ZCARD, ZCOUNT, ZINCRBY, ZRANGE, ZRANGEBYSCORE, ZRANK, ZREM, ZREMRANGEBYSCORE, ZREVRANGE, ZSCORE 增删改查设置键值,SET key value,有点相当于关系型数据库中的插入 取值,GET key,相当于关系型数据库中的查询 当我们设置值为integer时,使用INCR key,会让值自增1比如: 123SET key 10INCR keyGET key =&gt; 11 DEL key删除键值,相当于关系型数据库中的删除,返回1代表删除了一个键当使用INCR key时,如果键值不存在,会自动设置该键的值为1当不同的客户端连接同一数据库,使用下面的操作,就会出现数据不同步,INCR是原子性操作,保证数据同步 123x = GET countx = x + 1SET count x 客户端A连接,count = 10. 客户端B连接,count = 10. 客户端A设置count = 11. 客户端B设置count = 11. 所以请使用INCR key将键的值加1 123456INCR key //如果键不存在,创建该键值为0,再加1;否则直接加1INCRBY key number // 指定给key增加number,value为数字类型DECR key //减,其余一样DECRBY key number //减,其余一样//自增1,只能用于直接增加键对应的值,在集合中不能使用,比如HINCR命令是没有的 当设置了一个键值,使用EXPIRE key time设置多少时间(秒)后自动删除该键值.可以使用TTL key命令得到自动删除的剩余时间. 123456SET resource:lock &quot;Redis Demo&quot;EXPIRE resource:lock 120 //120秒后自动删除TTL resource:lock =&gt; 113 //113秒后自动删除TTL resource:lock =&gt; -2 //键值不存在TTL resource:lock =&gt; -1 //键值存在,没有设置自动删除时间 list有序集合有序集合,数组存储有顺序 123456789RPUSH friends &quot;Alice&quot; //如果没有list,就创建新的list,并在后面追加值RPUSH friends &quot;Bob&quot; //同上,在后面追加值 //friends = [&quot;Alice&quot;, &quot;Bob&quot;]LPUSH friends &quot;Sam&quot; //在list前面增加值,friends = [&quot;Sam&quot;, &quot;Alice&quot;, &quot;Bob&quot;]LRANGE friends 0 -1 =&gt; 1) &quot;Sam&quot;, 2) &quot;Alice&quot;, 3) &quot;Bob&quot; //打印所有LRANGE friends 0 1 =&gt; 1) &quot;Sam&quot;, 2) &quot;Alice&quot; //打印0到1(闭区间)LRANGE friends 1 2 =&gt; 1) &quot;Alice&quot;, 2) &quot;Bob&quot; //打印1到2(闭区间) 123LLEN friends =&gt; 3 //得到list长度LPOP friends =&gt; &quot;Sam&quot; //从list前面移除一个元素RPOP friends =&gt; &quot;Bob&quot; //从list后面移除一个元素 set无序集合无序集合,数组存储没有顺序 12345678910SADD superpowers &quot;flight&quot; //如果没有该键set,创建set,添加值SADD superpowers &quot;reflexes&quot; //添加值,无序set,只管添加,没有顺序SREM superpowers &quot;reflexes&quot; //删除set中的该元素SISMEMBER key member //如果member(set元素)在该键中存在返回1,否则返回0SMEMBERS key //输出set中所有元素sunion key1 key2 ...keyN //输出所有指定key(值为无序set)中的所有元素,顺序不固定 排序集合类似有序集合,需要给集合中每一个元素指定分数,用于排序 1234567891011ZADD hackers 1940 &quot;Alan Kay&quot; //如果该键对应的排序集合不存在,创建并添加新值ZADD hackers 1906 &quot;Grace Hopper&quot; ZADD hackers 1953 &quot;Richard Stallman&quot;ZADD hackers 1965 &quot;Yukihiro Matsumoto&quot;ZADD hackers 1916 &quot;Claude Shannon&quot;ZADD hackers 1969 &quot;Linus Torvalds&quot;ZADD hackers 1957 &quot;Sophie Wilson&quot;ZADD hackers 1912 &quot;Alan Turing&quot;ZRANGE hackers 2 4 =&gt; 1) &quot;Claude Shannon&quot;, 2) &quot;Alan key&quot;, 3) &quot;Richard Stallman&quot; //按元素指定分数排序后输出集合中2到4的元素(闭区间) 哈希就像在json中,key-value的value中,又包含了新的key-value 12345678910111213141516171819202122HSET user:1000 name &quot;John Smith&quot; //如果没有该键会自动创建,并添加新值HSET user:1000 email &quot;john.smith@example.com&quot;HSET user:1000 password &quot;s3cret&quot;HGETALL user:1000 //得到该键下所有的哈希key-value=&gt; 1) &quot;name&quot; //哈希键 2) &quot;John Smith&quot; //哈希值 3) &quot;email&quot; 4) &quot;john.smith@example.com&quot; 5) &quot;password&quot; 6) &quot;s3cret&quot;HMSET user:1001 name &quot;Mary Jones&quot; password &quot;hidden&quot; email &quot;mjones@example.com&quot; //设置多个哈希key-valueHGET user:1001 name =&gt; &quot;Mary Jones&quot; //得到键下哈希key对应的value//在哈希key-value中使用原子操作,让数字类型的value增加1HSET user:1000 visits 10HINCRBY user:1000 visits 1 =&gt; 11HDEL user:1000 visits //删除该键下哈希的keyHINCRBY user:1000 visits 1 =&gt; 1 总结然后就没有然后了,就到这儿了","link":"/2015/09/08/Redis-start/"},{"title":"Shell脚本学习第一天","text":"Shell脚本学习第一天第一个Shell脚本123echo &quot;打印是内容&quot; //输出内容到stdou 使用双引号&quot;&quot;read PERSON //从stdin获取输入并赋值给PERSON变量echo &quot;Hello, $PERSON&quot; //输出内容,同时输出PERSON变量的值 变量 定义变量varName=&quot;value&quot;,变量名和等号不能有空格 首字符(a-z,A-Z) 中间不能有空格,可以使用下划线 不能使用标点符号 不能使用bash里的关键字 For example: myUrl=&quot;http://yutiya.com/&quot; myNum=100 使用变量,在变量名前面加$符号即可变量名外面的花括号是可选的,是个好习惯 123your_name=&quot;yutiya&quot;echo $your_nameecho ${your_name} 如果不写,像下面这样,就会有问题… 1234for skill in Ada Coffe Action Java do echo &quot;I am good at ${skill}Script&quot;done 这里稍微提一下,Shell中使用#打头备注后面的内容,首行特殊表示用什么脚本解析器执行 重新定义变量 12345myUrl=&quot;http://yutiya.com/&quot;echo ${myUrl}myUrl=&quot;http://yutiya.com/&quot;echo ${myUrl} 只读变量 使用readonly命令定义为只读 12345#!/bin/bashmyUrl=&quot;http://yutiya.com/&quot;readonly myUrlmyUrl=&quot;http://yutiya.com/&quot; 赋值报错: 删除变量unset myUrl 12345#!/bin/bashmyUrl=&quot;http://yutiya.com/&quot;unset myUrlecho $myUrl 没有输出任何内容 特殊变量$ ehco $$,打印当前Shell进程的ID,即pid $0,当前脚本的文件名 $n,传递给脚本或函数的参数,n为数字,表示第几个参数 $#,传递给脚本或函数的参数个数 $*,传递给脚本或函数的所有参数 $@,传递给脚本或函数的所有参数,被双引号””包含时,与$*不同 $?,上个命令的退出状态,或函数的返回值 $$,当前Shell进程ID.对于Shell脚本,就是这些脚本所在的进程ID For example: 12345678#!/bin/bashecho &quot;File Name: $0&quot;echo &quot;First Parameter: $1&quot;echo &quot;First Parameter: $2&quot;echo &quot;Quoted Values: $@&quot;echo &quot;Quoted Values: $*&quot;echo &quot;Total Number of Parameter: $#&quot; $*和$@的区别: 12345678910111213141516171819202122232425262728293031#!/bin/bashecho &quot;\\$*=&quot; $*echo &quot;\\&quot;\\$*\\&quot;=&quot; &quot;$*&quot;echo &quot;\\$@=&quot; $@echo &quot;\\&quot;\\$@\\&quot;=&quot; &quot;$@&quot;echo &quot;print each param from \\$*&quot;for var in $*do echo &quot;$var&quot;doneecho &quot;print each param from \\$@&quot;for var in $@do echo &quot;$var&quot;doneecho &quot;print each param from \\&quot;\\$*\\&quot;&quot;for var in &quot;$*&quot;do echo &quot;$var&quot;doneecho &quot;print each param from \\&quot;\\$@\\&quot;&quot;for var in &quot;$@&quot;do echo &quot;$var&quot;done 可以看出来,使用变量的时候如果采用双引号””形式,$@会自动换行 $ echo &quot;上一次命令的退出状态&quot; $?,一般情况下成功为0,失败为1.也可以表示函数返回值 变量替换,命令替换,转义字符 转义字符: 12a=10echo -e &quot;Value of a is $a \\n&quot; 加上-e会把\\n解析为换行,否则就直接打印\\n \\\\ 反斜杠 \\a 警报 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 水平制表符(tab键) \\v 垂直制表符 -E选项禁止转义,默认不转义,-n禁止插入换行符 命令替换(Shell先执行命令,将输出结果暂时保存,在适当的地方输出)语法:`command`,这里是反引号,tab键上面那个 12345678910#!/bin/bashDATE=`date`echo &quot;Date is $DATE&quot;USERS=`who | wc -l`echo &quot;Logged in user are $USERS&quot;UP=`date ; uptime`echo &quot;Uptime is $UP&quot; 变量替换: 形式 说明 ${var}` 变量本来的值 ${var:-word} 如果变量var为空或已被删除,那么返回word,但不改变var的值 ${var:=word} 如果变量var为空或已被删除,那么返回word,并将改变var的值 ${var:?message} 如果变量var为空或已被删除,那么将消息messgae送到标准错误输出,可以用来检测变量var是否可以被正常赋值,若此替换出现在Shell脚本中,那么脚本将停止运行 ${var:+word} 如果变量var被定义,那么返回word,但不改变var的值 Shell运算expr:表达式计算工具 1234#!/bin/bashval=`expr 2 + 2`echo &quot;Total value: $val&quot; 输出结果:Total value: 4 注意: 变量和运算符之间要有空格,2 + 2 使用反引号进行命令替换,tab上面的按键 For example:12345678910111213141516171819202122232425262728#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a is equal to b&quot;fiif [ $a != $b ]then echo &quot;a is not equal to b&quot;fi 运算符 说明 + 加法 - 减法 * 乘法 / 除法 % 取余 = 赋值 == 相等.用于比较两个数字，相同则返回true != 不相等.用于比较两个数字,不相同则返回true 关系运算(只支持数字,不支持字符串,除非字符串的值是数字): 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/basha=10b=20if [ $a -eq $b ]then echo &quot;$a -eq $b : a is equal to b&quot;else echo &quot;$a -eq $b: a is not equal to b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a is not equal to b&quot;else echo &quot;$a -ne $b : a is equal to b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a is greater than b&quot;else echo &quot;$a -gt $b: a is not greater than b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a is less than b&quot;else echo &quot;$a -lt $b: a is not less than b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a is greater or equal to b&quot;else echo &quot;$a -ge $b: a is not greater or equal to b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a is less or equal to b&quot;else echo &quot;$a -le $b: a is not less or equal to b&quot;fi 运算符 说明 -eq 检测两个数是否相等,相等返回true -ne 检测两个数是否相等,不相等返回true -gt 检测左边的数是否大于右边的,如果是,则返回true -lt 检测左边的数是否小于右边的,如果是,则返回true -ge 检测左边的数是否大于等于右边的,如果是,则返回true -le 检测左边的数是否小于等于右边的,如果是,则返回true 布尔运算符: 1234567891011121314151617181920212223242526272829303132#!/bin/basha=10b=20if [ $a != $b ]then echo &quot;$a != $b : a is not equal to b&quot;else echo &quot;$a != $b: a is equal to b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then echo &quot;$a -lt 100 -a $b -gt 15 : returns true&quot;else echo &quot;$a -lt 100 -a $b -gt 15 : returns false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then echo &quot;$a -lt 100 -o $b -gt 100 : returns true&quot;else echo &quot;$a -lt 100 -o $b -gt 100 : returns false&quot;fiif [ $a -lt 5 -o $b -gt 100 ]then echo &quot;$a -lt 100 -o $b -gt 100 : returns true&quot;else echo &quot;$a -lt 100 -o $b -gt 100 : returns false&quot;fi 运算符 说明 ! 非运算,表达式为true则返回false,否则返回true -o 或运算,有一个表达式为true则返回true -a 与运算,两个表达式都为true才返回true 字符串运算符: 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then echo &quot;$a = $b : a is equal to b&quot;else echo &quot;$a = $b: a is not equal to b&quot;fiif [ $a != $b ]then echo &quot;$a != $b : a is not equal to b&quot;else echo &quot;$a != $b: a is equal to b&quot;fiif [ -z $a ]then echo &quot;-z $a : string length is zero&quot;else echo &quot;-z $a : string length is not zero&quot;fiif [ -n $a ]then echo &quot;-n $a : string length is not zero&quot;else echo &quot;-n $a : string length is zero&quot;fiif [ $a ]then echo &quot;$a : string is not empty&quot;else echo &quot;$a : string is empty&quot;fi 运算符 说明 = 检测两个字符串是否相等,相等返回true != 检测两个字符串是否相等,不相等返回true -z 检测字符串长度是否为0,为0返回true -n 检测字符串长度是否为0,不为0返回true str 检测字符串是否为空,不为空返回true(直接判断变量) 文件测试运算符:检测unix文件的各种属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/bashfile=&quot;/Users/admin/Desktop/blogrefer/test.sh&quot;if [ -r $file ]then echo &quot;File has read access&quot;else echo &quot;File does not have read access&quot;fiif [ -w $file ]then echo &quot;File has write permission&quot;else echo &quot;File does not have write permission&quot;fiif [ -x $file ]then echo &quot;File has execute permission&quot;else echo &quot;File does not have execute permission&quot;fiif [ -f $file ]then echo &quot;File is an ordinary file&quot;else echo &quot;This is sepcial file&quot;fiif [ -d $file ]then echo &quot;File is a directory&quot;else echo &quot;This is not a directory&quot;fiif [ -s $file ]then echo &quot;File size is not zero&quot;else echo &quot;File size is zero&quot;fiif [ -e $file ]then echo &quot;File exists&quot;else echo &quot;File does not exist&quot;fi 操作符 说明 -b file 检测文件是否是块设备文件,如果是,则返回true -c file 检测文件是否是字符设备文件,如果是,则返回true -d file 检测文件是否是目录,如果是,则返回true -f file 检测文件是否是普通文件(既不是目录,也不是设备文件),如果是,则返回true -g file 检测文件是否设置了SGID位,如果是,则返回true -k file 检测文件是否设置了粘着位(Sticky Bit),如果是,则返回true -p file 检测文件是否是具名管道,如果是,则返回true -u file 检测文件是否设置了SUID位,如果是,则返回true -r file 检测文件是否可读,如果是,则返回true -w file 检测文件是否可写,如果是,则返回true -x file 检测文件是否可执行,如果是,则返回true -s file 检测文件是否为空(文件大小是否为0),不为空返回true -e file 检测文件(包括目录)是否存在,如果是,则返回true Shell字符串 单引号: str='this is a string' 注意: 单引号里的任何字符都会原样输出,使用的变量无效 单引号字符串中不能出现单引号(对单引号使用转义符后也不行) 双引号: str=&quot;Hello, I know you are \\&quot;$your_name\\&quot;! \\n&quot;,可以使用变量,可以出现转义字符 字符串拼接 12345your_name=&quot;yutiya&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1 获取字符串长度 12string=&quot;abcd&quot;echo ${#string} #输出 4 取子字符串 12string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出liba 查找子字符串 注意: mac终端的expr命令只能进行加减乘除 12string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is` # 输出3,只匹配is中的i 数组123456789101112array_name=(value0 value1 value2 value3)或者array_name=( value0 value1 value2 value3)也可以这样array_name[0]=value0array_name[1]=value1array_name[2]=value2 可以不使用连续的下标,而且下标的范围没有限制 读取:1- 获取所有元素:```${array_name[*]}```或者```${array_name[@]} 获取数组的长度:1- 取得数组单个元素的长度:```length=${#array_name[n]} echo 普通$ echo arg 转义$ echo &quot;\\&quot; It is a test \\&quot;&quot; 变量$ echo &quot;$name is a number&quot;,变量与其他字符相连请加上${name} 换行$ echo &quot;Oh! \\n&quot; 不换行$ echo &quot;OK! \\c&quot; 结果输出到文件$ echo &quot;test&quot; &gt; filename 原样输出$ echo 'chars' 显示命令结果`date` 双引号可有可无,单引号原样输出","link":"/2015/08/07/Shell脚本学习第一天/"},{"title":"Shell脚本学习第二天","text":"第二天格式化输出必须显示添加换行符 1printf &quot;Hello, Shell\\n&quot; printf命令语法:printf format-string [arguments...] 123456789101112131415#!/bin/bashprintf &quot;%d %s \\n&quot; 1 &quot;abc&quot;# 单引号和双引号一样printf &apos;%d %s \\n&apos; 2 &quot;bcd&quot;# 即使不使用引号也一样printf %s cde# 多余的参数仍然遵循现有格式printf %s abc defprintf &quot;%s\\n&quot; abc def# 未设置参数 %s 被NULL代替 %d被0代替printf &quot;%s and %d \\n&quot;# 参数传递错误 printf &quot;The first program always prints &apos;%s, %d&apos; \\n&quot; &quot;Hello&quot; &quot;Shell&quot; if…else语句if语句: 1234if [ expression ]then # do somethingfi if…else语句: 123456if [ expression ]then # do somethingelse # do somethingfi 多层使用: 123456789if [ expression 1 ]then # do somethingelif [ expression 2]then # do somethingelse # do somethingfi if…else语句也可以写成一行,以命令行的方式来运行1if test $[2*3] -eq $[1+5]; then echo &quot;The two numbers are equal!&quot;; fi; test命令用于检测条件是否成立,与方括号[]类似$[]还计算了结果保存到变量中 分支语句12345678910case 值 in 结果1) # do something ;; 模式2) #do something ;; *) # 相当于default ;; esac 123456789101112131415#!/bin/bashoption=&quot;${1}&quot;case ${option} in -f) FILE=&quot;${2}&quot; echo &quot;File name is $FILE&quot; ;; -d) DIR=&quot;${2}&quot; echo &quot;Dir name is $DIR&quot; ;; *) echo &quot;`basename ${0}`:usage: [-f file] | [-d directory]&quot; exit 1 # 命令结束,返回状态1 ;;esac for循环1234for 变量 in 列表do # do somethingdone 列表为一组值, 每个值通过空格分隔,每循环一次,就将列表中的下一个值赋给变量.列表是可选的,如果不用它,for循环使用命令行的位置参数 显示主目录下以 .bash 开头的文件： 123456#!/bin/bashfor FILE in $HOME/.bash*do echo $FILEdone while循环1234while 条件do # do somethingdone until循环1234until 条件do # do somethingdone 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done break 跳出循环break n 跳出n层循环 continue 结束本次循环 函数12345function_name(){}或者function function_name(){} 1234567#!/bin/bashHello () { echo &quot;Hello World!&quot;}# Invoke your custom functionHello 1234567891011121314#!/bin/bashfunWithReturn(){ echo &quot;The function is to get the sum of two numbers...&quot; echo -n &quot;Input first number: &quot; read aNum echo -n &quot;Input another number: &quot; read anotherNum echo &quot;The two numbers are $aNum and $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturn# 捕获返回值使用$?ret=$?echo &quot;The sum of two numbers is $ret !&quot; 使用unset .f function_name来删除函数如果你希望直接从终端调用函数,可以将函数定义在主目录下的 .profile 文件,这样每次登录后，在命令提示符后面输入函数名字就可以立即调用. 函数参数123456789101112#!/bin/bashfunWithParam(){ echo &quot;The value of the first parameter is $1 !&quot; echo &quot;The value of the second parameter is $2 !&quot; echo &quot;The value of the tenth parameter is $10 !&quot; echo &quot;The value of the tenth parameter is ${10} !&quot; echo &quot;The value of the eleventh parameter is ${11} !&quot; echo &quot;The amount of the parameters is $# !&quot; # 参数个数 echo &quot;The string of the parameters is $* !&quot; # 传递给函数的所有参数}funWithParam 1 2 3 4 5 6 7 8 9 34 73 特殊变量 说明 $# 传递给函数的参数个数 $* 显示所有传递给函数的参数 $@ 与$*相同,但是略有区别,请查看Shell学习第一天 $? 函数的返回值 输入输出重定向一般情况下,每个 Unix/Linux 命令运行时都会打开三个文件: 标准输入文件(stdin):stdin的文件描述符为0,Unix程序默认从stdin读取数据 标准输出文件(stdout):stdout 的文件描述符为1,Unix程序默认向stdout输出数据 标准错误文件(stderr):stderr的文件描述符为2,Unix程序会向stderr流中写入错误信息 命令 说明 command &gt; file 将输出重定向到 file command &lt; file 将输入重定向到 file command &gt;&gt; file 将输出以追加的方式重定向到 file n &gt; file 将文件描述符为 n 的文件重定向到 file n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file n &gt;&amp; m 将输出文件 m 和 n 合并 n &lt;&amp; m 将输入文件 m 和 n 合并 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null:$ command &gt; /dev/null /dev/null是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果如果希望屏蔽 stdout 和 stderr，可以这样写:$ command &gt; /dev/null 2&gt;&amp;1 Here Document:Here Document 目前没有统一的翻译,这里暂译为”嵌入文档“.Here Document 是 Shell 中的一种特殊的重定向方式,它的基本的形式如下: 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command 文件包含. filename或者source filename","link":"/2015/08/07/Shell脚本学习第二天/"},{"title":"exports和module.exports的区别","text":"exports和module.exports的区别我们今天主要来理解exports和module.exports的区别写了一些代码,有问题请指教 123456789101112131415// file: app.jsvar a = {name: &apos;yutiya&apos;};var b = a;console.log(a);console.log(b);b.name = &apos;Yutiya&apos;;console.log(a);console.log(b);b = {name: &apos;test&apos;};console.log(a);console.log(b); 结果: 123456{ name: &apos;yutiya&apos; }{ name: &apos;yutiya&apos; }{ name: &apos;Yutiya&apos; }{ name: &apos;Yutiya&apos; }{ name: &apos;Yutiya&apos; }{ name: &apos;test&apos; } 使用b变量修改属性,a变量的属性也会跟着变,说明两个变量使用一块内存,也就是说a和b都是指针(c和c++中)类型,指向同一个对象给b变量赋值新的对象,b变量指向新的内存区域 下面我们来看看exports和module.exports 123456//file: testModule.js// 什么也不写//file: app.jsvar m = require(&apos;./testModule&apos;);//如果不写./应该在 node_mudules/ 目录下开始找,找不到就没有了console.log(m); 结果: 1{} 说明module.exports和exports初始化的时候都是{}空下一步: 12//file: testModule.jsexports = {name: &apos;yutiya&apos;}; 结果: 1{} 说明引用一个模块,并没有引用exports变量,而是module.exports变量,试试 12//file: testModule.jsmodule.exports = {name: &apos;yutiya&apos;}; 结果: 1{ name: &apos;yutiya&apos; } 现在我们知道了,模块导入对象或方法均是在module.exports中我们继续发现 12//file: testModule.jsexports.name = &apos;yutiya&apos;; 结果: 1{ name: &apos;yutiya&apos; } 现在能知道,一开始module.exports和exports均指向同一个对象,给对象设置属性,不管使用两个变量中的哪一个均可,可是外部引用只是引用module.exports所以我们总结一下,给该模块增加属性,两个均可使用,如果导出模块为方法或者给module.exports重新赋值,那么引用该模块得到的就会是module.exports赋值的内容 123456789//file: testModule.jsmodule.exports = function(){ console.log(&apos;testModule&apos;); console.log(exports);};//file: app.jsvar m = require(&apos;./testModule&apos;);m(); 结果是这样: 12testModule{} 文章写得不好,如果您还是毕竟晕,不如上百度谷歌一下","link":"/2015/08/14/exports和module-exports的区别/"},{"title":"hadoop安装","text":"hadoop安装(CentOS 6.5)安装(root) ssh无密码登陆123456789$ groupadd hadoop $ useradd -g hadoop hadoop$ vi /etc/passwd 去掉`hadoop:x:`中的x,在sudoers中添加hadoop,问题列表有已经列出$ yum install openssh-server // 安装SSH$ su hadoop // 切换至hadoop用户$ ssh-keygen -t rsa -P \"\" // 生成公钥$ cat /home/hadoop/.ssh/id_rsa.pub &gt;&gt; /home/hadoop/.ssh/authorized_keys // 将公钥加入自动验证，用于免登陆 $ ssh localhost // yes无密码设置成功,需要关闭selinux防火墙 下载、设置hadoop (配置后调用脚本启用即可,root) 12345$ wget http://101.44.1.4/files/1101000003B75211/download.oracle.com/otn-pub/java/jdk/8u51-b16/jdk-8u51-linux-x64.tar.gz$ wget http://101.44.1.7/files/3244000003ADEE48/mirrors.cnnic.cn/apache/hadoop/common/stable/hadoop-2.7.1.tar.gz $ tar -zxvf hadoop-2.7.1-src.tar.gz $ chown -R hadoop:hadoop hadoop-2.7.1-src/ $ ln -s hadoop-2.7.1-src/ hadoop 安装jdk(root) 123456789$ wget http://download.oracle.com/otn-pub/java/jdk/8u51-b16/jdk-8u51-linux-x64.tar.gz?AuthParam=1437748835_74bbfb625f56836583016856473da65a$ tar -zxvf jdk-8u51-linux-x64.tar.gz //解压 $ vi /etc/profile //设置环境变量JAVA_HOME 追加: export JAVA_HOME=/usr/local/jdk1.8.0_51 //上面解压的路径 export PATH=$PATH:$JAVA_HOME/bin$ source /etc/profile // 执行修改$ java -version // 测试$ javac -version //测试 配置hadoop-单机模式(hadoop) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/home/hadoop目录下建立:tmp、hdfs、hdfs/data、hdfs/name hadoop-2.7.1目录下：$ vi etc/hadoop/core-site.xml ` &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file://home/hadoop/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;10240&lt;/value&gt; &lt;/property&gt; `$ vi etc/hadoop/hdfs-site.xml ` &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; `$ vi etc/hadoop/mapred-site.xml //需要从mapred-site.xml.example复制一个 ` &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9002&lt;/value&gt; &lt;/property&gt; `$ vi etc/hadoop/hadoop-env.sh ` export JAVA_HOME=/usr/local/jdk1.8.0_51 `$ bin/hadoop namenode -format // 初始化 $ sbin/start-all.sh // 开启hadoop$ sbin/stop-all.sh // 停止$ jps // 查看相关的运行信息 Web访问，要先开放端口或者直接关闭防火墙 浏览器打开http://192.168.0.182:8088/ 浏览器打开http://192.168.0.182:50070/ 问题 (root)123$ su // 切换root用户，需要输入密码$ uname -a //查询用户信息 $ ifconfig -a // 显示网卡信息 用户不在sudoers中的解决方法 123$ vi /etc/sudoers 在root ALL=(ALL) ALL行后追加 username ALL=(ALL) ALL 开机自动联网 &amp; 修改网卡静态IP 12345678910111213// eth0 代表第一张网卡(请对应自己的网卡)$ vi /etc/sysconfig/network-scripts/ifcfg-eth0 ` ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=static IPADDR=192.168.248.130 NETMASK=255.255.255.0 GETEWAY=192.168.248.1 DNS1=192.168.248.1 `// 重启网卡$ service network restart 关闭selinux防火墙: 12345// 关闭selinux: $ sudo vi /etc/selinux/config ` SELINUX=disabled ` 无法使用hadoop进行无密码登陆的时候，可以修改权限再试 12$ chmod 600 ～/.ssh/authorized_keys$ chmod 700 ~/.ssh 启动hadoop运行未知主机错误 1234$ vi /etc/hosts ` 127.0.0.1 localhost 主机名 // 将自己的主机ip解析为127.0.0.1 ` 卸载OpenJDK 1234567891011121314先查看 rpm -qa | grep java显示如下信息:java-1.4.2-gcj-compat-1.4.2.0-40jpp.115java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5//卸载rpm -e --nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5//如果上面的行不通,就用yum来卸载吧,搞湿对吧yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-40jpp.115yum -y remove java java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5","link":"/2015/07/25/hadoop安装/"},{"title":"迈向世界的第一步","text":"迈向世界的第一步 使用Hexo! 非常棒. 查看 documentation 获取更多信息. 使用过程中遇到问题，请查看troubleshooting 得到帮助或者上GitHub提问. 开始吧 安装: npm install hexo-cli -g 初始化: hexo init 安装组件: npm install (自动完成) 安装主题: git clone themes/ 配置: _config.yml 生成: hexo g 本地部署: hexo s 新的篇章1$ hexo new \"新的开始\" 更多: Writing 1$ hexo deploy 更多: Deployment 文章配置| title: 标题| date: 日期| categories: 分类12345678可以输入多个，顺序性 ` categories: [Hexo, Use] `或者`categories: - Hexo - Use` | tags: 标记","link":"/2015/07/23/hello-world/"},{"title":"Hexo Bug","text":"在文章的md文件中不能使用下面这种搁置,否则出错 1- 取得数组单个元素的长度:`length=${#array_name[n]}`","link":"/2015/08/13/hexo-Bug/"},{"title":"httpbody中字符编码问题-iOS解决方案","text":"httpbody中字符编码问题在工作中遇到一个问题,本来可以直接将字典转换成json,再转换成nsdata,设置到httpbody中就可以请求服务器了,可是服务器不方便解析(其实是做服务器开发的不知道怎么解析收到的数据|_|)最后只能将字典遍历键值对变成查询字符串的样子设置在body中 For Example: 123456{ &quot;username&quot; : &quot;yutiya&quot;, &quot;age&quot; : 18}变成: username=yutiya&amp;age=18 通常上传到服务器的数据都需要编码一次,不过我上传的数据全是[a-zA-Z0-9]等等,不用编码也是可以的可是问题出现了,上传到服务器的数据中有+号,看了阮一峰的博客,从中可以看到+在服务器会被自动解析成空格简直是见了鬼,然后就得改代码呗 1234NSString *str = @&quot;username=yutiya&amp;lock=abc+bbc+ccc&quot;;NSLog(@&quot;%@&quot;, [str stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]);console &gt;&gt;&gt;: 2015-07-30 14:51:07.212 httpbody中的字符编码[6470:156038] username=yutiya&amp;lock=abc+bbc+ccc 然而并没有什么卵用,好,我换了一个方法 1234NSString *str = @&quot;username=yutiya&amp;lock=abc+bbc+ccc&quot;;NSLog(@&quot;%@&quot;, [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]);console &gt;&gt;&gt;: 2015-07-30 14:52:50.828 httpbody中的字符编码[6488:156742] username=yutiya&amp;lock=abc+bbc+ccc 然而也没有什么卵用,在阮一峰的博客中描述了,只有采用对url进行编码才会把+号等字符进行编码,+号编码后是%2B,我承认我当时就2B了 上html代码就知道对url编码是什么样子了: 123456789101112131415&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.write(encodeURIComponent(&quot;http://www.baidu.com/&quot;)+ &quot;&lt;br /&gt;&quot;) document.write(encodeURIComponent(&quot;http://www.baidu.com/My first/&quot;)+ &quot;&lt;br /&gt;&quot;) document.write(encodeURIComponent(&quot; &quot;) + &quot;&lt;br /&gt;&quot;); document.write(encodeURIComponent(&quot;+&quot;))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt;: http%3A%2F%2Fwww.baidu.com%2F http%3A%2F%2Fwww.baidu.com%2FMy%20first%2F %20 %2B 知道了吧,你这样传到服务器,服务器就能收到了噢,因为服务器会自动解码,具体以什么方式解码,请看阮一峰的博客,大师呢!NEXT,那OC代码怎么写呢?磨叽磨叽,我来给你瞅瞅 12345NSString *str = @&quot;username=yutiya&amp;lock=abc+bbc+ccc&quot;;NSString *encodeStr = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)str, NULL, (CFStringRef)(@&quot;:/?#[]@!$ &amp;&apos;()*+,;=\\&quot;&lt;&gt;%{}|\\\\^~`&quot;), kCFStringEncodingUTF8));NSLog(@&quot;%@&quot;, encodeStr);console &gt;&gt;&gt;: 2015-07-30 15:04:50.196 httpbody中的字符编码[6589:162380] username%3Dyutiya%26lock%3Dabc%2Bbbc%2Bccc 是不是很神奇,就出来了,上面的代码在ARC环境下调用,可以在服务器进行测试噢会编码@&quot;:/?#[]@!$ &amp;'()*+,;=\\&quot;&lt;&gt;%{}|\\\\^~“`指定的这些字符噢 好了,说实话涉及到CoreFoundation对象,内存管理就更麻烦了,没事儿,给你们找了一篇博客参考Objective-C 和 Core Foundation 对象相互转换的内存管理总结标题虽长,只用command + c,^_^~ 参考一下吧! 我测试了另一个方法 12345NSString *str = @&quot;username=yutiya&amp;lock=abc+bbc+ccc&quot;;NSString *encodeStr = (NSString *)CFBridgingRelease(CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault, (CFStringRef)str, (CFStringRef)(@&quot;:/?#[]@!$ &amp;&apos;()*+,;=\\&quot;&lt;&gt;%{}|\\\\^~`&quot;), kCFStringEncodingUTF8));NSLog(@&quot;%@&quot;, encodeStr);console &gt;&gt;&gt;: 2015-07-30 15:16:42.803 httpbody中的字符编码[6676:167136] username=yutiya&amp;lock=abc+bbc+ccc 好像体现出AddingPercentEscapes和ReplacingPercentEscapes的不同了,有问题的发邮件给我噢","link":"/2015/07/30/httpbody中字符编码问题-iOS解决方案/"},{"title":"iOS7新特性UIDynamic","text":"iOS-UIDynamic初试UIDynamic是iOS7引入的UIKit动力学,目的是将2D物理引擎引入UIKit.最明显的就是短信界面,拖动的时候有物理效果.通常的时候我们仅使用CA和UIView的动画即可,除非我们需要引入非常逼真的交互设计的时候才使用来看看新的基本概念: UIDynamicItem:用来描述一个力学物体的状态,其实就是实现了UIDynamicItem委托的对象,或者抽象为有面积有旋转的质点. UIDynamicBehavior:动力行为的描述,用来指定UIDynamicItem应该如何运动,定义适用的物理规则.一般使用该类的子类对象来对一组UIDynamicItem对象应该遵守的行为规则进行描述. UIDynamicAnimator:动画的播放者,动力行为(UIDynamicBehavior)的容器,添加到容器的行为将发挥作用 ReferenceView:等同于力学参考系,当添加力学的UIView是ReferenceView的子view或就是它本身的时候,动力就会发生作用.但如果是它本身,虽然能发挥作用,但这个力学仿真就不逼真了 喵神原文: http://onevcat.com/2013/06/uikit-dynamics-started/ onevcat 写段代码演示下: 123456789101112131415161718192021@interface ViewController ()@property (nonatomic, strong) UIDynamicAnimator *animator;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; UIView *aView = [[UIView alloc] initWithFrame:CGRectMake(100, 50, 100, 100)]; aView.backgroundColor = [UIColor lightGrayColor]; [self.view addSubview:aView]; UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; UIGravityBehavior *gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[aView]]; [animator addBehavior:gravityBeahvior]; self.animator = animator; } 123UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];===&gt;UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:aView]; 比第一个要快,这就不逼真了,而且这样写并不对 接下来就是物理仿真了,有重力,得有碰撞啊,这样无界的就没有意义了碰撞也有一个UIDynamicBehavior的子类UICollisionBehavior. 1234567891011121314151617- (void)viewDidLoad { [super viewDidLoad]; UIView *aView = [[UIView alloc] initWithFrame:CGRectMake(100, 50, 100, 100)]; aView.backgroundColor = [UIColor lightGrayColor]; aView.transform = CGAffineTransformRotate(aView.transform, 45); [self.view addSubview:aView]; UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; UIGravityBehavior *gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[aView]]; [animator addBehavior:gravityBeahvior]; self.animator = animator; UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc] initWithItems:@[aView]]; collisionBehavior.translatesReferenceBoundsIntoBoundary = YES; [animator addBehavior:collisionBehavior];} 在里边加一了一个旋转角,是不是很有意思 translatesReferenceBoundsIntoBoundary设置以self.view为边界.setTranslatesReferenceBoundsIntoBoundaryWithInsets:方法也可以,更复杂的addBoundaryWithIdentifier:forPath:来添加UIBezierPath,或者addBoundaryWithIdentifier:fromPoint:toPoint:来添加一条线段为边界可以设置collisionBehavior的代理,监听事件.具体的自己看看代码 UIAttachmentBehavior描述一个view和一个锚相连接的情况 UISnapBehavior描述view吸附的情况 UIPushBehavior描述对view施加力的情况 UIDynamicItemBehavior相当于自定义描述了,摩擦、阻力等一大堆我不知道的.","link":"/2015/09/14/iOS7-Dynamic/"},{"title":"icarus主题的使用","text":"icarus主题的使用初始化123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装主题1234567891011121314$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Rename &apos;themes\\icarus\\_config.yml.example&apos; to &apos;themes\\icarus\\_config.yml&apos; ; Copy &apos;themes\\icarus\\_config.yml.site.example&apos; to your hexo blog&apos;s root directory and rename it to &apos;_config.yml&apos; ; Then modify &apos;theme&apos; setting in &apos;_config.yml&apos; to &apos;icarus&apos;. 更新12$ cd themes/icarus $ git pull Categories &amp; Tags 的使用问题12345678910To enable custom categories page and tags page, just copy the categories folder and tags folder under your theme's _source foler into your site's source folder. Then edit theme's _config.yml and add the following lines: # Header menu: ` Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ` RSS的使用问题123456789101112131415$ npm install hexo-generator-feed --save In _config.yml: ` plugins: - hexo-generator-feed ` In the theme configuration: # Header menu: ` RSS: atom.xml &lt;&lt;&lt; add ` 自定义文章的缩略图12thumbnail: http://example.com/thumbnail.jpg &lt;&lt;&lt; addbanner: http://example.com/banner.jpg &lt;&lt;&lt; add","link":"/2015/07/23/icarus主题的使用/"},{"title":"maven的安装及使用","text":"maven的安装及使用目标 安装 使用maven搞定HelloWorld 一些构建命令 安装下载地址: http://maven.apache.org/download.cgi 而选其一进行下载.解压.放置到一个你喜欢的文件夹,切记不要删除.配置环境确保在系统环境变量中配置了JAVA_HOME的键值,然后再添加一个MAVEN_HOME配置系统全局的,sudo vi /etc/profile,在后面加入内容即可,不要输入错了,否则臣妾真的救不了你噢 1234567891011JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home ## MAC下,jdk就在这个目录,linux安装配置请百度谷歌export PATH=$JAVA_HOME/bin:$PATHMAVEN_HOME=/usr/local/maven/maven-3.3.3 ## 这里是我解压存放的路径export PATH=$MAVEN_HOME/bin:$PATHexport JAVA_HOME ## 该键不仅需要加入PATH(用于终端使用java命令),maven也会使用,不加入,你会一直呵呵的export MAVEN_HOME 使用mvn -v来测试是否安装成功. 使用maven搞定HelloWorld先来说说我们的文件夹格式 1234567891011maven01├─ src| ├─ main| | └─ java| | └─ 包名(java的包名就是无数个文件夹,不写了com.xxx.maven01.model,四个文件夹,自己去建)| | └─ 类文件.java| └─ test| └─ java| └─ 包名(和上面的包名是一样的,写测试用例的而已com.xxx.maven01.model)| └─ 类文件.java└─ pom.xml 下面写代码,类和测试类都写,是为了找一个依赖junit,maven有一个中央仓库在远程服务器中,一般情况下,我们依赖的jar包都在上面;但是一会儿我们会说,maven其实先在本地仓库中查找jar包,如果没有才会在中央服务器中下载jar包,所以第一次使用maven需要下载很多东西 main-&gt;java-&gt;…&gt;HelloWorld.java: 1234567package com.xxx.maven01.model;public class HelloWorld { public String sayHello() { return &quot;Hello World!&quot;; }} test-&gt;java-&gt;…&gt;HelloWorldTest.java: 123456789101112package com.xxx.maven01.model;import org.junit.*; //能找到个依赖不容易,简而高效嘛import org.junit.Assert.*;public class HelloWorldTest { @Test public void testHello() { Assert.assertEquals(&quot;Hello World!&quot;, new HelloWorld().sayHello()); } } 好,现在我们来写pom.xml,maven就靠解析这玩意儿知道我们需要依赖什么,然后才去下载的 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- maven版本,固定的 --&gt; &lt;groupId&gt;com.xxx.maven01&lt;/groupId&gt; &lt;!-- 组织名,公司名反写+项目名 --&gt; &lt;artifactId&gt;maven01-model&lt;/artifactId&gt; &lt;!-- 项目名-模块名 --&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;!-- 指定版本号,这个你随意,遵循版本规则来 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- 在中央处理器中的jar包,唯一,简写 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 最后一步,在maven01目录下执行mvn compile编译生成字节码,mvn test执行测试,mvn package打包jar,mvn clean清理生成的字节码等等,mvn install将生成的jar安装到本地仓库,生成的字节码和打包的jar,在target目录下找 一些构建命令上面我们讲述了mvn install能将生成的jar安装到本地仓库,现在我们要来使用本地仓库中的jar目录结构一致,这温暖一如从前 main-&gt;java-&gt;…&gt;Hello.java: 123456789package com.xxx.maven02.util;import com.xxx.maven01.model.HelloWorld; //引入jar包种的类,本地仓库,我们打包的,记不得自宫吧public class Hello { public String sayHi() { return new HelloWorld().sayHello(); //调用我们自己写的类实例方法 }} test-&gt;java-&gt;…-&gt;HelloTest.java: 123456789101112package com.xxx.maven02.util;import org.junit.*;import org.junit.Assert.*;public class HelloTest { @Test public void testHi() { Assert.assertEquals(&quot;Hello World!&quot;, new Hello().sayHi()); } } 搞定,我们应该注意的是pom的写法: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinpu.maven02&lt;/groupId&gt; &lt;artifactId&gt;maven02-util&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xinpu.maven01&lt;/groupId&gt; &lt;artifactId&gt;maven01-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 执行mvn compile,BUILD SUCCESS,请先安装maven01-model的jar到本地仓库 通常在我们开始一个新的项目的时候,我们会手动创建很多目录来管理资源,就比如我们之前创建目录结构,是有多累,我们来讲述使用mvn插件手动帮我们生成目录结构,呵呵,你肯定觉得我在逗你. 使用mvn archetype:generate插件来生成目录结构 1234567891011121314151617181920//回车跳过Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 644: //选择版本,6,回车Choose a number: 6: 6//默认groupId,似曾相似, com.xxx.maven03Define value for property &apos;groupId&apos;: : com.xxx.maven03//默认artifactId, maven03-serviceDefine value for property &apos;artifactId&apos;: : maven03-service//版本 1.0.0Define value for property &apos;version&apos;: 1.0-SNAPSHOT: : 1.0.0//包名 com.xxx.maven03.serviceDefine value for property &apos;package&apos;: com.xxx.maven03: : com.xxx.maven03.service// y Y: : 搞定,生成成功了,自己看看,有点晕吧,包名就是无数个文件夹.还有一种方式,就是直接在命令中指定这一堆参数,到时候可以少输入一些,而已 1mvn archetype:generate -DgroupId=com.xxx.maven04 -DartifactId=maven04-demo -Dversion=1.0.0SNAPSHOT -Dpackage=com.xxx.maven04.demo 仓库 当使用mvn构建项目时,先在本地仓库中查找jar包,没有就会前往远程中央服务器查找,没有就报错 在maven目录的lib下maven-model-builder-3.3.3.jar解压,找到pom-4.0.0.xml,可以看到 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 记录了maven所使用的中央仓库,访问https://repo1.maven.org/maven2/,列出了仓库中所有包含的jar加速国内访问可以设置国内镜像源,maven目录下conf文件夹settings.xml的146行mirrors 示例,配置了就只会使用镜像源了,所以一般不使用镜像源: 123456&lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;central mirror in China&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 修改本地仓库位置 默认本地仓库为用户主目录的.m2文件夹下 1234root L .m2 L repository L ... 配置刚才的settings.xml,53行,下面是示例将settings.xml复制到仓库的根目录下,以后升级maven可以不用再配置settings 1&lt;localRepository&gt;/usr/loca/repo&lt;/localRepository&gt; 生命周期 完整的项目构建过程包括:清理&gt;编译&gt;测试&gt;打包&gt;集成测试&gt;验证&gt;部署 maven生命周期: clean 清理项目 default 构建项目 site 生成项目站点 clean、compile、test、package、install这五个过程,后面的命令都会执行前面的命令 clean的三个阶段: pre-clean 执行清理前的工作 clean 清理上一次构建生成的所有文件 post-clean 执行清理后的文件 default阶段compile test package install都属于默认阶段 site的三个阶段: pre-site 在生成项目站点前要完成的工作 site 生成项目的站点文档 post-site 在生成项目站点后要完成的工作 site-deploy 发布生成的站点到服务器上 maven插件 例举一个source插件,在maven01的pom中dependencies后配置指定在运行package命令的时候打包源代码 1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; mvn package会帮我们打包源码,生成jar源码文件在target目录下 修改settings.xml使用eclipse创建项目使用对应的jre版本 找到182行,添加 1234567891011121314&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; pom.xml简述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!-- 当前pom版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;反写的公司网址+项目名&lt;/groupId&gt; &lt;artifactId&gt;项目名+模块名&lt;/artifactId&gt; &lt;!-- snapshot 快照 alpha 内部测试 beta 公测 release 稳定 GA 正式发布 --&gt; &lt;version&gt;当前项目的版本号,1.0.0,大版本.分支.小版本&lt;/version&gt; &lt;packaging&gt;默认打包为jar,可以不写, 或者war、zip、pom&lt;/packaging&gt; &lt;name&gt;项目描述名&lt;/name&gt; &lt;url&gt;项目网址&lt;/url&gt; &lt;description&gt;项目描述&lt;/description&gt; &lt;developers&gt;开发人员名单&lt;/developers&gt; &lt;licenses&gt;开源协议&lt;/licenses&gt; &lt;organization&gt;组织信息&lt;/organization&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;scope&gt;&lt;/scope&gt;&lt;!-- 依赖范围 --&gt; &lt;optional&gt;&lt;/optional&gt;&lt;!-- 设置依赖是否可选,false子项目默认自动引入,true子项目必须自行引入 --&gt; &lt;!-- 解除依赖传递 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;parent&gt;&lt;/parent&gt; &lt;modules&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt;","link":"/2015/09/15/maven安装及使用/"},{"title":"Nodejs第一课","text":"nodejs lesson1Mac下:sudo npm install -g express-generator@3 (express3)sudo npm install -g express-generator (express4) 下面的学习均按照express3进行 创建express项目:1234$ express -e nodejs-demo$ cd nodejs-demo$ npm install$ vi app.js app.js: 12345678var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function(req, res){ res.send(&apos;Hello World&apos;);});app.listen(3000, function(){ console.log(&apos;app is listening at port 3000&apos;);}); 执行$ node app.js访问localhost:3000,可以看到打印的Hello World!. URL我们熟悉的url其实是这个样子:&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; ftp:ftp://账号:密码@主机/目录或文件 现在的使用的url精简成了这样:&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;","link":"/2015/07/28/nodejs-lesson1/"},{"title":"Nodejs第十课","text":"benchmaek怎么写目标有一个字符串var number = '100',我们要将它转换成Number类型的100三个选项: + , parseInt, Number测试哪种方法更快 知识点 学习使用benchmark库 学习使用 http://jsperf.com/ 分享你的benchmark 课程内容首先得有一个benchmark库, https://github.com/bestiejs/benchmark.js貌似很久没更新的样子,依旧可以使用按照实例跟着写: 123456789101112131415161718192021222324252627282930313233343536var int1 = function (str) { return +str;};var int2 = function (str) { return parseInt(str, 10);};var int3 = function (str) { return Number(str);};var Benchmark = require(&apos;benchmark&apos;);var suite = new Benchmark.Suite;var number = &apos;100&apos;;suite .add(&apos;+&apos;, function(){ int1(number); }) .add(&apos;parseInt&apos;, function(){ int2(number); }) .add(&apos;Number&apos;, function(){ int3(number); }) //每个测试完成后,输出 .on(&apos;cycle&apos;, function(event){ console.log(String(event.target)); }) .on(&apos;complete&apos;, function(){ console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;)); }) //默认勾选async .run({ &apos;async&apos; : true }); 我们实现了三个函数,然后添加测试 在线分享如果需要在线分享你的js benchmark,进入这个网站: http://jsperf.com/ .比如alsotang分享的 http://jsperf.com/math-perf-alsotang","link":"/2015/08/31/nodejs-lesson10/"},{"title":"Nodejs第十一课","text":"作用域与闭包讲解 this, var, (function(){}) 知识点 理解js中var的作用域 了解闭包的概念 理解this的指向 课程内容12345678910111213141516var parent = function () { var name = &quot;parent_name&quot;; var age = 13; var child = function () { var name = &quot;child_name&quot;; var childAge = 0.3; console.log(name, age, childAge); }; child(); console.log(name, age, childAge);};parent(); 学过一点别的编程语言肯定都会直觉的认为,内部函数可以访问外部函数的变量,外部不能访问内部函数的变量.因此childAge在parent中会报错.如果声明变量是少了var,就声明就全局变量了.在Nodejs中,全局变量会被定义在global对象下,在浏览器中,全局变量会被定义在window下.如果需要定义全局变量,请显示的定义在global或window对象上. 如果使用Sublime Text,可以按照SublimeLinter插件,进行错误检测,默认使用JSHint作为JavaScript校验器作者使用Mac OS X, Sublime text 2-&gt;Preferences-&gt;Package Setting-&gt;SublimeLinter-&gt;Setting - User配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ &quot;sublimelinter&quot;: &quot;save-only&quot;, //运行模式 &quot;sublimelinter_popup_errors_on_save&quot;: true, &quot;sublimelinter_executable_map&quot;: { &quot;javascript&quot;: &quot;D:/Program Files/nodejs/node.exe&quot;, &quot;css&quot;: &quot;D:/Program Files/nodejs/node.exe&quot; }, &quot;jshint_options&quot;: { &quot;strict&quot;: false, &quot;quotmark&quot;: &quot;single&quot;, //只能使用单引号 &quot;noarg&quot;: true, &quot;noempty&quot;: true, //不允许使用空语句块{} &quot;eqeqeq&quot;: true, //!==和===检查 &quot;undef&quot;: true, &quot;curly&quot;: true, //值为true时，不能省略循环和条件语句后的大括号 &quot;forin&quot;: true, //for in hasOwnPropery检查 &quot;devel&quot;: true, &quot;jquery&quot;: true, &quot;browser&quot;: true, &quot;wsh&quot;: true, &quot;evil&quot;: true, &quot;unused&quot;: &quot;vars&quot;, //形参和变量未使用检查 &quot;latedef&quot;: true, //先定义变量，后使用 &quot;globals&quot;: { &quot;grunt&quot;: true, &quot;module&quot;: true, &quot;window&quot;: true, &quot;jQuery&quot;: true, &quot;$&quot;: true, &quot;global&quot;: true, &quot;document&quot;: true, &quot;console&quot;: true, &quot;setTimeout&quot;: true, &quot;setInterval&quot;: true } }, &quot;csslint_options&quot;: { &quot;adjoining-classes&quot;: false, &quot;box-sizing&quot;: false, &quot;box-model&quot;: false, &quot;compatible-vendor-prefixes&quot;: false, &quot;floats&quot;: false, &quot;font-sizes&quot;: false, &quot;gradients&quot;: false, &quot;important&quot;: false, &quot;known-properties&quot;: false, &quot;outline-none&quot;: false, &quot;qualified-headings&quot;: false, &quot;regex-selectors&quot;: false, &quot;shorthand&quot;: false, &quot;text-indent&quot;: false, &quot;unique-headings&quot;: false, &quot;universal-selector&quot;: false, &quot;unqualified-attributes&quot;: false }} 运行模式: 12345SublimeLinter 的运行模式,总共有四种,含义分别如下： true - 在用户输入时在后台进行即时校验 false - 只有在初始化的时候才进行校验 &quot;load-save&quot; - 当文件加载和保存的时候进行校验 &quot;save-only&quot; - 当文件被保存的时候进行校验 校验引擎,Mac下使用which node获取路径 12345&quot;sublimelinter_executable_map&quot;:{ &quot;javascript&quot;:&quot;/usr/local/bin/node&quot;, &quot;css&quot;:&quot;/usr/local/bin/node&quot;} 更多的请参考文档: http://jshint.com/docs/#options 作者英文只有小学一级,搞不定 在JavaScript中,变量的局部作用域是函数级别的.不同于C语言,在C语言中作用域是块级别.js中,函数中声明的变量在整个函数中都可以使用. 12345678function foo() { for (var i = 0; i &lt; 10; i++) { var value = &quot;hello world&quot;; } console.log(i); console.log(value);}foo(); 所以我们养成一个好习惯,提前声明 闭包http://coolshell.cn/articles/6731.html 这篇博客可以参考参考 12345for (var i = 0; i &lt; 5; i++) { setTimeout(function() { console.log(i); }, 5);} 程序不会按照我们预期的结果打印1 2 3 4 5.因为setTimeout中的i是对外层i的引用.当setTimeout的代码被解释的时候,运行时只是记录了i的引用,而不是记录值.当setTimeout被触发时取i值,i已迭代为5,所以打印了5次5 1234567for (var i = 0; i &lt; 5; i++) { (function(idx) { setTimeout(function() { console.log(idx); }, 5); })(i);} 程序变成这样,结果和预期一样 一些闭包的例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*//闭包中使用局部变量是引用而非直接拷贝function s() { var num = 6; var sa = function() { console.log(num); }; num++; return sa;}var sa = s();sa();// ==&gt;// 7*//*//多个函数绑定同一个闭包,引用同一个变量function setupSomeGlobals () { var num = 666; gAlertNumber = function(){ console.log(num); }; gIncreaseNumber = function() { num++; }; gSetNumber = function(x) { num = x; };}setupSomeGlobals();gAlertNumber();gIncreaseNumber();gAlertNumber();gSetNumber(18);gAlertNumber();// ==&gt;// 666// 667// 18*//*//当在一个循环中赋值函数时,这些函数将绑定同样的闭包,函数内使用了外部变量的引用function buildList(list) { var result = []; for(var i = 0; i &lt; list.length; i++) { var item = &apos;item&apos; + list[i]; result.push(function(){ console.log(item + &apos; &apos; + list[i]); }); } return result;}function testList() { var fnlist = buildList([1, 2, 3]); for (var j = 0; j &lt; fnlist.length; j++) { fnlist[j](); };}testList();*/// ==&gt;// item3 undefined// item3 undefined// item3 undefined/*//外部函数所有局部变量都在闭包内,即使这个变量声明在内部函数定义之后function sa() { var sas = function(){ console.log(alice); }; var alice = &quot;Hello world&quot;; return sas;}var hello = sa();hello();// ==&gt;// Hello world*//*// 每次函数调用的时候创建一个新的闭包function newClosure(someNum, someRef) { var num = someNum; var anArray = [1, 2, 3]; var ref = someRef; return function(x) { num += x; anArray.push(num); console.log(&apos;num: &apos; + num + &apos;\\nanArray&apos; + anArray.toString() + &apos;\\nref.someVar&apos; + ref.someVar); };}closure1 = newClosure(400, { someVar: &apos;closure 1&apos;});closure2 = newClosure(400, { someVar: &apos;closure 2&apos;});closure1(5);closure2(-10);// ==&gt;// num: 405// anArray1,2,3,405// ref.someVarclosure 1// num: 390// anArray1,2,3,390// ref.someVarclosure 2*/ this在函数执行时,this总是指向调用该函数的对象.要判断this的指向,其实就是判断this所在的函数属于谁.this出现的场景分为四类: 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过apply或call或bind来改变this的所指 函数有所属对象是:指向所属对象 函数有所属对象是,通常通过.表达式调用,这时的this自然指向所属对象. 12345678var obj = { value : 100};obj.getValue = function() { // { value: 100, getValue: [Function] } // 其实就是obj对象本身 console.log(this); return this.value;};console.log(obj.getValue()); getValue()方法属于对象obj,有obj进行.调用,因此this指向对象obj 函数没有所属对象:指向全局对象 12345678910var obj = { value : 100};obj.getValue = function() { var foo = function () { console.log(this.value); // =&gt; undefined console.log(this); // 全局global对象 }; foo(); return this.value;};console.log(obj.getValue()); 在上述代码块中,foo函数虽然定义在getValue的函数体内,但实际上它既不属于getValue也不属于obj.foo并没有绑定在任何对象上,所以当调用时,它的this指针指向了全局对象global. 构造器中的this:指向新对象 js中,我们通过new关键词来调用构造函数,此时this会绑定在该新对象上. 12345var objClass = function () { this.value = 100;};var create = new objClass();console.log(create.value); // =&gt; 100 在js中,构造函数、普通函数、对象方法、闭包,这死者没有明确界线. apply、call调用和bind绑定:指向绑定的对象 apply()方法接受两个参数,第一个是函数运行的作用域,另一个是参数数组(arguments)call()方法第一个参数的意义与apply()方法相同,只是其他的参数需要一个个列举出来简单来说,call的方式更接近我们平时调用函数,而apply需要我们传递Array形式的数组给它.他们可以互相转换. 123456789var obj = { value: 100 };var foo = function () { console.log(this);};foo(); //全局变量 globalfoo.apply(obj); foo.call(obj);var n = foo.bind(obj);n();","link":"/2015/09/01/nodejs-lesson11/"},{"title":"Nodejs第十二课","text":"线上部署Node.js:heroku目标将这个项目部署上heroku,成为一个线上项目.参考原作者的App, http://serene-falls-9294.herokuapp.com/ 知识点 学习heroku的线上部署:(https://www.heroku.com/) 内容使用git clone git@github.com:Ricardo-Li/node-practice-2.git命令克隆项目代码中的Procfile文件: 1web: node app.js 一个是app.js文件: 1app.listen(process.env.PORT || 5000); 这两者都是为了部署heroku所做. pass平台提供语言环境支持,对于Node.js来说,它要帮我们安装package.json中的依赖,然后启动我们的项目,并把外部流量导入我们的项目,让我们的项目提供服务.第一个是启动项目,第二个时引入外部流量我们提供Procfile知道heroku平台启动我们的项目我们的程序原本监听5000端口,但是heroku并不知道.可以在Procfile中指定,可以会有冲突,heroku使用了主动策略,提供了一个环境变量process.evn.PORT来供我们的App监听.首先下载工具包 https://toolbelt.heroku.com/ ,执行heroku login登录官方教程: https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction进入node-practice-2目录,执行heroku create,heroku会随机给我们分配应用名称和git仓库.是用git remote -v命令查看一下远程库的一些信息 1234heroku https://git.heroku.com/arcane-coast-6683.git (fetch)heroku https://git.heroku.com/arcane-coast-6683.git (push)origin git@github.com:Ricardo-Li/node-practice-2.git (fetch)origin git@github.com:Ricardo-Li/node-practice-2.git (push) 现在将我们的代码推送到heroku远程库git push heroku masterheroku自动检测出我们是Node.js程序,帮我们安装依赖,然后按照Procfile启动.push完成后,按照官方教程heroku ps:scale web=1可以看到我们有一个App正在运行使用heroku open,自动打开浏览器访问.然后,就这么多了","link":"/2015/09/06/nodejs-lesson12/"},{"title":"Nodejs第十三课","text":"持续集成平台:travis知识点 学习使用travis-ci对项目进行持续集成测试(https://travis-ci.org/) 课程内容首先来瞅瞅这个项目: https://github.com/Ricardo-Li/node-practice-3(项目已失效,自己随便写一个叭)我们是学习噢,不是抄袭别人的噢,好记性不如烂笔头嘛 类似这样的badges(徽章),在很多开源项目中都可以看到.前者是告诉我们,该项目目前测试是通过的;后者是告诉我们,这个测试的行覆盖率是多少.行覆盖率当然是越多越好,很重要.使用travis平台,因为它可以让你明白自己的项目在一个”空白环境”中,是否能够正确运行;也可以测试项目在不同的Node.js版本下运行,有没有兼容行问题.当在自己的机器上开发测试的时候,一般使用特定的Node.js版本,测试过了,需要手动切换版本再测试,相对比较繁琐.所以选择travis帮你把项目在不同的Node.js版本下运行.也可以在我们安装依赖,忘记写入package.json的时候,及时发现. travis的虚拟机技术玩得很6,每次测试都是新的环境,环境中只有Linux最基本的依赖.build-essential、wget、git等.Node.js运行时都是即时安装的. travis默认的依赖对于每个用户都一样,所以你要你在上边测试通过,你就不用担心别的用户安装不上了 原文地址: https://github.com/alsotang/node-lessons/tree/master/lesson13 官网: https://travis-ci.org/ 授权使用github账户进行登录,然后克隆你仓库中的某个项目来进行平台测试 在项目根目录中配置.travis.yml,告知平台怎么运行改项目 1234567language: node_jsnode_js:- &apos;0.8&apos;- &apos;0.10&apos;- &apos;0.11&apos;script: make test 这个文件描述的信息是: 这是一个node.js应用 使用0.8、0.10和0.11三个版本来运行 运行该项目的命令是make test 项目根目录有该配置文件,平台克隆项目的时候,就能自动跑起来了 每一个travis项目都可以得到一个图片地址,图片上描述了当前的测试状态. 另外 https://coveralls.io/ 平台可以测试行覆盖率. 将上述的图片放到项目的README.md中,B格提升了,有木有 平台官方文档: http://docs.travis-ci.com/user/database-setup/ 如果使用了MongoDB,请在配置文件中写上 12services: mongodb","link":"/2015/10/16/nodejs-lesson13/"},{"title":"Nodejs第十五课","text":"mongdb和mongoose使用简介安装mac: brew update 需要先安装Homebrew.更新brew install mongdb 安装sudo mongod -—config /usr/local/etc/mongod.conf 启动 简短实例123456789101112131415161718192021222324252627// 引入mongoose模块var mongoose = require(&apos;mongoose&apos;);// 连接对应的数据库// mongodb是协议名称,localhost 是ip地址// 端口号默认27017,test为数据库名称// mongodb中不需要建立数据库,当连接是如果数据库不存在,会自动创建// mongodb的安全性很残废,不过不用担心,反正也只能本机连接mongoose.connect(&apos;mongodb://localhost/test&apos;);// 创建一个名为Cat的model,它在数据库中的名字根据传给mongoose.model的第一个参数决定// mongoose会将名词变为附属,在这里,collection的名字会是&apos;cats&apos;// 这个model中定义了,String类型的name,String数组类型的friends,Number类型的age// mongodb中大多数的数据类型都可以用js的原生类型来表示.至于说String的长度是多少,Number的精度是多少.String的最大限度是16MB,Number的整型是64-bit,浮点数的话,js中`0.1 + 0.2`的结果都是乱来的..就不指望什么了..// 这里可以看到各种示例: http://mongoosejs.com/docs/schematypes.htmlvar Cat = mongoose.model(&apos;Cat&apos;, { name: String, friends: [String], age: Number,});// new一个新对象,kitty,接着赋值var kitty = new Cat({ name: &apos;kitty&apos;, friends: [&apos;tom&apos;, &apos;jerry&apos;]});kitty.age = 3;//调用save方法,mongoose会去的mongodb中的test数据库,存入一条数据kitty.save(function(err){ if(err) { console.log(&apos;gg&apos;); }}); 使用mongo连接查看 1234show dbs //显示所有数据库use test //切换数据库show collections db.cats.find()","link":"/2015/09/23/nodejs-lesson15/"},{"title":"Nodejs第二课","text":"使用外部模块目标建立一个新的项目，实现在浏览器中访问http://localhost:3000/?q=yutiya时输出yutiya的md5值 简介 package.json该文件包含了项目的依赖等各种信息,当在项目文件夹下执行npm install会自动读取该文件,安装依赖到node_modules文件夹下,最后运行就可以跑起来了 12$ mkdir lesson2 &amp;&amp; cd lesson2$ npm init 终端会提示输入信息,可以全部回车,然后使用编辑器打开,就能看到对应的键值了init的目的就是为了生成package.json 执行$ npm install express utility --save会自动在json文件中添加依赖项,类似下面这样 1234&quot;dependencies&quot;: { &quot;express&quot;: &quot;^4.13.1&quot;, &quot;utility&quot;: &quot;^1.4.0&quot;} node_modules也会有对应的文件内容产生噢 编写代码,文件(app.js): 123456789101112131415//引入依赖var express = require(&apos;express&apos;);var utility = require(&apos;utility&apos;);//建立实例var app = express();app.get(&apos;/&apos;, function(req, res){ //取值 var q = req.query.q; //使用utility模块计算md5 var md5Value = utility.md5(q); res.send(md5Value);});app.listen(3000, function(req, res){ console.log(&apos;app is running at port 3000&apos;);}); 运行$ node app.js,访问http://localhost:3000/,报错 1234567891011TypeError: Not a string or buffer at TypeError (native) at Hash.update (crypto.js:119:16) at Object.hash (/Users/admin/Desktop/lesson2/node_modules/utility/lib/crypto.js:31:7) at Object.md5 (/Users/admin/Desktop/lesson2/node_modules/utility/lib/crypto.js:44:18) at /Users/admin/Desktop/lesson2/app.js:9:25 at Layer.handle [as handle_request] (/Users/admin/Desktop/lesson2/node_modules/express/lib/router/layer.js:95:5) at next (/Users/admin/Desktop/lesson2/node_modules/express/lib/router/route.js:131:13) at Route.dispatch (/Users/admin/Desktop/lesson2/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/Users/admin/Desktop/lesson2/node_modules/express/lib/router/layer.js:95:5) at /Users/admin/Desktop/lesson2/node_modules/express/lib/router/index.js:277:22 可以看到，这个错误是从 crypto.js 中抛出的。 这是因为，当我们不传入 q 参数时，req.query.q 取到的值是 undefined，utility.md5 直接使用了这个空值，导致下层的 crypto 抛错。 访问http://localhost:3000/?q=yutiya,显示4d493e09017ac232455bca190f9eb2e8 查看utility文档,修改成显示yutiya的sha1值 12var md5Value = utility.md5(q); res.send(md5Value); 打印结果7fadc38a6aecdf260414e2b3752f81c954d56d3b","link":"/2015/07/29/nodejs-lesson2/"},{"title":"Nodejs第三课","text":"使用superagent和cheerio完成简单爬虫 使用superagent抓取网页 使用cheerio分析网页 课程内容Node.js 异步特性特别厉害,想要学习,利用爬虫的场景比较适合. 原文中介绍了爬github有rate limit限制,作者是菜鸟,不懂,所以也爬了Node.js开源社区CNode社区 使用了三个依赖,分别是express、superagent和cheerio superagent是一个http方面的库,可以发起get或post请求cheerio大家可以理解为Node.js版的jQuery,使用方式和jQuery一样两者均为链式操作,用起来特别爽 走你:1234$ npm init // 初始化$ npm install &lt;packeagename&gt; --save $ touch app.js$ vi app.js 第一步我们尝试打印出superagent发出的get请求的内容 12345678910111213141516var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function(req, res, next){ superagent.get(&apos;https://cnodejs.org&apos;) .end(function(err, sres){ if (err) { return next(err); } res.send(sres); })});app.listen(3000, function(req, res){ console.log(&apos;app is running at port 3000&apos;);}); 我们分析网页内容,修改代码 12345678910111213141516171819app.get(&apos;/&apos;, function(req, res, next){ superagent.get(&apos;https://cnodejs.org&apos;) .end(function(err, sres){ if (err) { return next(err); } var $ = cheerio.load(sres.text); var items = []; // 根据网页内容分析 $(&apos;#topic_list .topic_title&apos;).each(function(idx, element){ var $element = $(element); items.push({ title: $element.attr(&apos;title&apos;), href: $element.attr(&apos;href&apos;) }); }); res.send(items); })}); 试一试,是不是完成了一个小小的爬虫程序? 下一步我们继续挑战,修改代码,把作者也分析出来,试试吧,下面附上代码 123456789101112131415161718192021 app.get(&apos;/&apos;, function(req, res, next){ superagent.get(&apos;https://cnodejs.org&apos;) .end(function(err, sres){ if (err) { return next(err); } var $ = cheerio.load(sres.text); var items = []; $(&apos;#topic_list .cell&apos;).each(function(idx, element){ var $element = $(element); var $top_title = $element.find(&apos;.topic_title&apos;); var $author = $element.find(&apos;.user_avatar img&apos;); items.push({ title: $top_title.attr(&apos;title&apos;), href: $top_title.attr(&apos;href&apos;), author: $author.attr(&apos;title&apos;) }); }); res.send(items); })});","link":"/2015/07/29/nodejs-lesson3/"},{"title":"Nodejs第四课","text":"使用eventproxy控制并发目标输出CNode社区社区首页的所有主题的标题,链接和第一条评论,以 json 的格式。原文地址:lesson4 示例:123456789101112[ { &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;, &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;, &quot;comment1&quot;: &quot;呵呵呵呵&quot; }, { &quot;title&quot;: &quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;, &quot;href&quot;: &quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;, &quot;comment1&quot;: &quot;沙发！&quot; }] 挑战输出帖子的作者,以及他在cnode社区的积分值,这里和原文不同,作者看错了,不过也算挑战示例: 12345678910[ { &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;, &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;, &quot;comment1&quot;: &quot;呵呵呵呵&quot;, &quot;author1&quot;: &quot;auser&quot;, &quot;score1&quot;: 80 }, ...] 原文: 以上文目标为基础,输出 comment1 的作者,以及他在 cnode 社区的积分值。就一个地方不同,我过后会修改代码附上 首先app.js这样写,获取文章的url到数组: 1234567891011121314151617181920212223242526var eventproxy = require(&apos;eventproxy&apos;);var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);// url 模块是 Node.js 标准库里面的// http://nodejs.org/api/url.htmlvar url = require(&apos;url&apos;);var cnodeUrl = &apos;https://cnodejs.org/&apos;;superagent.get(cnodeUrl) .end(function (err, res) { if (err) { return console.error(err); } var topicUrls = []; var $ = cheerio.load(res.text); // 获取首页所有的链接 $(&apos;#topic_list .topic_title&apos;).each(function (idx, element) { var $element = $(element); // $element.attr(&apos;href&apos;) 本来的样子是 /topic/542acd7d5d28233425538b04 // 我们用 url.resolve 来自动推断出完整 url,变成 // https://cnodejs.org/topic/542acd7d5d28233425538b04 的形式 // 具体请看 http://nodejs.org/api/url.html#url_url_resolve_from_to 的示例 var href = url.resolve(cnodeUrl, $element.attr(&apos;href&apos;)); topicUrls.push(href); }); console.log(topicUrls); }); Copy:（这段是在太多,偷师学艺）用 js 写过异步的同学应该都知道,如果你要并发异步获取两三个地址的数据,并且要在获取到数据之后,对这些数据一起进行利用的话,常规的写法是自己维护一个计数器。 先定义一个 var count = 0,然后每次抓取成功以后,就 count++。如果你是要抓取三个源的数据,由于你根本不知道这些异步操作到底谁先完成,那么每次当抓取成功的时候,就判断一下 count === 3。当值为真时,使用另一个函数继续完成操作。 而 eventproxy 就起到了这个计数器的作用,它来帮你管理到底这些异步操作是否完成,完成之后,它会自动调用你提供的处理函数,并将抓取到的数据当参数传过来。 假设我们不使用 eventproxy 也不使用计数器时,抓取三个源的写法是这样的: 123456789101112// 参考 jquery 的 $.get 的方法$.get(&quot;http://data1_source&quot;, function (data1) { // something $.get(&quot;http://data2_source&quot;, function (data2) { // something $.get(&quot;http://data3_source&quot;, function (data3) { // something var html = fuck(data1, data2, data3); render(html); }); });}); 使用计数器: 12345678910111213141516171819202122232425(function () { var count = 0; var result = {}; $.get(&apos;http://data1_source&apos;, function (data) { result.data1 = data; count++; handle(); }); $.get(&apos;http://data2_source&apos;, function (data) { result.data2 = data; count++; handle(); }); $.get(&apos;http://data3_source&apos;, function (data) { result.data3 = data; count++; handle(); }); function handle() { if (count === 3) { var html = fuck(result.data1, result.data2, result.data3); render(html); } }})(); 用 eventproxy,写出来是这样的: 1234567891011121314var ep = new eventproxy();ep.all(&apos;data1_event&apos;, &apos;data2_event&apos;, &apos;data3_event&apos;, function (data1, data2, data3) { var html = fuck(data1, data2, data3); render(html);});$.get(&apos;http://data1_source&apos;, function (data) { ep.emit(&apos;data1_event&apos;, data); });$.get(&apos;http://data2_source&apos;, function (data) { ep.emit(&apos;data2_event&apos;, data); });$.get(&apos;http://data3_source&apos;, function (data) { ep.emit(&apos;data3_event&apos;, data); }); 大家自行学习一下这个 API 吧:[eventproxy])https://github.com/JacksonTian/eventproxy#%E9%87%8D%E5%A4%8D%E5%BC%82%E6%AD%A5%E5%8D%8F%E4%BD%9C) 目标完成代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var eventproxy = require(&apos;eventproxy&apos;);var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);//加载标准库模块urlvar url = require(&apos;url&apos;);var cnodeUrl = &apos;https://cnodejs.org/&apos;;superagent.get(cnodeUrl) .end(function(err, res){ if (err) { return console.error(err); }; var $ = cheerio.load(res.text); var topicUrls = []; //获取链接 $(&apos;#topic_list .topic_title&apos;).each(function(idx, element){ var $element = $(element); var href = url.resolve(cnodeUrl, $element.attr(&apos;href&apos;)); topicUrls.push(href); }); // console.log(topicUrls); // 创建对象实例 var ep = new eventproxy(); //监听topicUrls.length次&apos;topic_html&apos;再行动 ep.after(&apos;topic_html&apos;, topicUrls.length, function(topics){ //topic是个数组,包含了40次ep.emit(&apos;topic_html&apos;, pair)中的那40个pair topics = topics.map(function(topicPair){ var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; var $ = cheerio.load(topicHtml); return ({ title: $(&apos;.topic_full_title&apos;).text().trim(), href: topicUrl, comment: $(&apos;.reply_content&apos;).eq(0).text().trim() }); }); console.log(&apos;final:&apos;); console.log(topics); }); topicUrls.forEach(function(topicUrl){ superagent.get(topicUrl) .end(function(err, sres){ console.log(&apos;fetch: &apos; + topicUrl + &apos; successful&apos;); ep.emit(&apos;topic_html&apos;, [topicUrl, sres.text]); }); }); }); 目标代码看似没问题,可是服务器异常(服务器受不了),我采用了递归完成了挑战,估计服务器更受不了,因为如果访问有错误,我就采用递归又去访问,直到40次全部完成 因为看错了,所以这是自己写的挑战自我的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119var eventproxy = require(&apos;eventproxy&apos;);var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);//加载标准库模块urlvar url = require(&apos;url&apos;);var cnodeUrl = &apos;https://cnodejs.org/&apos;;superagent.get(cnodeUrl) .end(function(err, res){ if (err) { return console.error(err); }; var $ = cheerio.load(res.text); //一级,得到所有主题 var topicUrls = []; //获取链接 $(&apos;#topic_list .topic_title&apos;).each(function(idx, element){ var $element = $(element); var href = url.resolve(cnodeUrl, $element.attr(&apos;href&apos;)); topicUrls.push(href); }); // 创建对象实例 var ep = new eventproxy(); //监听topicUrls.length次&apos;topic_html&apos;,再执行 ep.after(&apos;topic_html&apos;, topicUrls.length, function(topics){ //topic是个数组,包含了40次ep.emit(&apos;topic_html&apos;, pair)中的那40个pair // array.map方法会遍历数组并且每遍历一次执行一次callback // callback执行后的返回值组合起来又形成一个新的数组 /* topics = topics.map(function(topicPair){ var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; console.log(topicHtml); var $ = cheerio.load(topicHtml); return ({ title: $(&apos;.topic_full_title&apos;).text().trim(), href: topicUrl, comment: $(&apos;.reply_content&apos;).eq(0).text().trim() }); }); console.log(&apos;final:&apos;); console.log(topics); */ ep.after(&apos;user&apos;, topics.length, function(users){ var finalInfors = users.map(function(user){ var preInfo = user[0]; var userHtml = user[1]; var $ = cheerio.load(userHtml); var authorScore = $(&apos;.userinfo .user_profile .big&apos;).text(); return ({ title: preInfo[0], href: preInfo[1], comment: preInfo[2], author: preInfo[3], score: authorScore }); }); console.log(&apos;final:&apos;); console.log(finalInfors); }); //这里如果有错误,就使用递归 //请不要多次测试,服务器负载受不了 //正式因为服务器负载问题,有时候访问会出错,所以使用了递归 var getScore = function(userUrl, topicInfor){ superagent.get(userUrl) .end(function(err, ssres){ if (err) { getScore(userUrl, topicInfor); return; } console.log(&apos;fetch suburl:&apos; + userUrl + &quot; success&quot;); ep.emit( &apos;user&apos;, [ topicInfor, ssres.text ] ); }); } topics.forEach(function(topic){ var topicUrl = topic[0]; var topicHtml = topic[1]; var $ = cheerio.load(topicHtml); var $userInfo = $(&apos;.user_card .user_name a&apos;); getScore( url.resolve(cnodeUrl, $userInfo.attr(&apos;href&apos;)), [ $(&apos;.topic_full_title&apos;).text().trim(), topicUrl, $(&apos;.reply_content&apos;).eq(0).text().trim(), $userInfo.text() ] ); }); }); //这里如果有错误,就使用递归 //请不要多次测试,服务器负载受不了 //正式因为服务器负载问题,有时候访问会出错,所以使用了递归 var getText = function(topicUrl){ superagent.get(topicUrl) .end(function(err, sres){ if (err) { getText(topicUrl); return; } console.log(&apos;fetch: &apos; + topicUrl + &quot; success&quot;); ep.emit( &apos;topic_html&apos;, [ topicUrl, sres.text ] ); }); } topicUrls.forEach(function(topicUrl){ getText(topicUrl); }); }); 原文中挑战目标的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var eventproxy = require(&apos;eventproxy&apos;);var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);//加载标准库模块urlvar url = require(&apos;url&apos;);var cnodeUrl = &apos;https://cnodejs.org/&apos;;superagent.get(cnodeUrl) .end(function(err, res){ if (err) { return console.error(err); }; var $ = cheerio.load(res.text); //一级,得到所有主题 var topicUrls = []; //获取链接 $(&apos;#topic_list .topic_title&apos;).each(function(idx, element){ var $element = $(element); var href = url.resolve(cnodeUrl, $element.attr(&apos;href&apos;)); topicUrls.push(href); }); // 创建对象实例 var ep = new eventproxy(); ep.after(&apos;topic_html&apos;, topicUrls.length, function(topics){ ep.after(&apos;user&apos;, topics.length, function(users){ var finalInfors = users.map(function(user){ var preInfo = user[0]; var userHtml = user[1]; var $ = cheerio.load(userHtml); var authorScore = $(&apos;.userinfo .user_profile .big&apos;).text(); return ({ title: preInfo[0], href: preInfo[1], comment: preInfo[2], author: preInfo[3], score: authorScore }); }); console.log(&apos;final:&apos;); console.log(finalInfors); }); //这里如果有错误,就使用递归 //请不要多次测试,服务器负载受不了 //正式因为服务器负载问题,有时候访问会出错,所以使用了递归 var getScore = function(userUrl, topicInfor){ superagent.get(userUrl) .end(function(err, ssres){ if (err) { getScore(userUrl, topicInfor); return; } console.log(&apos;fetch suburl:&apos; + userUrl + &quot; success&quot;); ep.emit( &apos;user&apos;, [ topicInfor, ssres.text ] ); }); } topics.forEach(function(topic){ var topicUrl = topic[0]; var topicHtml = topic[1]; var $ = cheerio.load(topicHtml); var $authorInfor = $(&apos;.author_content&apos;).eq(0).find(&quot;.reply_author&quot;); getScore( url.resolve(cnodeUrl, $authorInfor.attr(&apos;href&apos;)), [ $(&apos;.topic_full_title&apos;).text().trim(), topicUrl, $(&apos;.reply_content&apos;).eq(0).text().trim(), $authorInfor.text().trim() ] ); }); }); //这里如果有错误,就使用递归 //请不要多次测试,服务器负载受不了 //正式因为服务器负载问题,有时候访问会出错,所以使用了递归 var getText = function(topicUrl){ superagent.get(topicUrl) .end(function(err, sres){ if (err) { getText(topicUrl); return; } console.log(&apos;fetch: &apos; + topicUrl + &quot; success&quot;); ep.emit( &apos;topic_html&apos;, [ topicUrl, sres.text ] ); }); } topicUrls.forEach(function(topicUrl){ getText(topicUrl); }); }); 前两段代码亲测可用,第三段代码只是修改了获取作者积分的时候传递的url和作者的名称也许你会问为什么没有测试,因为社区发帖子的人很多啊,有一些帖子是没有人回复的,获取不到评论测试的时候还以为代码有错了,555","link":"/2015/07/29/nodejs-lesson4/"},{"title":"Nodejs第五课","text":"使用async控制并发原文链接: https://github.com/alsotang/node-lessons/tree/master/lesson5博主已学习,并做记录 目标建立一个lesson5项目,在其中编写代码代码入口app.js , $ node app.js, 会输出CNode社区首页的所有主题的标题、链接和第一条评论,以json格式注意: 与lesson4不同. 并发连接数需要控制在5个 输出实例: 123456789101112[ { &quot;title&quot;: &quot;【公告】发招聘帖的同学留意一下这里&quot;, &quot;href&quot;: &quot;http://cnodejs.org/topic/541ed2d05e28155f24676a12&quot;, &quot;comment1&quot;: &quot;呵呵呵呵&quot; }, { &quot;title&quot;: &quot;发布一款 Sublime Text 下的 JavaScript 语法高亮插件&quot;, &quot;href&quot;: &quot;http://cnodejs.org/topic/54207e2efffeb6de3d61f68f&quot;, &quot;comment1&quot;: &quot;沙发！&quot; }] 知识点 学习 async 的使用. 这里有个详细的 async demo演示: https://github.com/alsotang/async_demo 学习使用 async 来控制并发连接数 当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。大部分场景是前者 开始:首先,我们伪造一个 fetchUrl(url, callback) 函数,这个函数的作用,就是当你调用它时,它会返回url的页面内容回来. 123fetchUrl(url, function(err, content){ // do something with &apos;content&apos;}); 当然,我们这里的返回内容是假的,返回延时是随机的.并且在它被调用时,会告诉你它现在一共被多少个地方并发的调用着. 1234567891011var connectCurrentCount = 0;var fetchUrl = function(url, callback) { // delay 的值在2000以内,是个随机的整数 var delay = parseInt((Math.random() * 10000000) % 2000, 10); connectCurrentCount++; console.log(&apos;现在的并发连接数为-&gt;&apos;, connectCurrentCount, &apos; ,正在抓取的url地址为-&gt;&apos;, url, &apos; ,耗时&apos; + delay + &apos;毫秒&apos;); setTimeout(function(){ connectCurrentCount--; callback(null, url + &apos; html content&apos;); }, delay); }; 我们继续,来伪造一组链接 1234var urls = [];for(var i = 0; i &lt; 30; i++) { urls.push(&apos;http://datasource...&apos; + i);} 有图有真相: 接着,我们使用 async.mapLimit 来并发抓取,获取结果. 123456async.mapLimit(urls, 5, function(url, callback) { fetchUrl(url, callback);}, function (err, result) { console.log(&apos;final:&apos;); console.log(result);}); 完整的代码是这样. 12345678910111213141516171819202122var async = require(&apos;async&apos;);var connectCurrentCount = 0;var fetchUrl = function(url, callback) { // delay 的值在2000以内,是个随机的整数 var delay = parseInt((Math.random() * 10000000) % 2000, 10); connectCurrentCount++; console.log(&apos;现在的并发连接数为-&gt;&apos;, connectCurrentCount, &apos; ,正在抓取的url地址为-&gt;&apos;, url, &apos; ,耗时&apos; + delay + &apos;毫秒&apos;); setTimeout(function(){ connectCurrentCount--; callback(null, url + &apos; html content&apos;); }, delay); };var urls = [];for(var i = 0; i &lt; 30; i++) { urls.push(&apos;http://datasource...&apos; + i);}async.mapLimit(urls, 5, function(url, callback) { fetchUrl(url, callback);}, function (err, result) { console.log(&apos;final:&apos;); console.log(result);}); 有图有真相: 作为补充,完成了我们的目标代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 加载模块var async = require(&apos;async&apos;);var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);var url = require(&apos;url&apos;);// 主站链接var cnodeUrl = &apos;https://cnodejs.org/&apos;;// 当前连接数var connectCurrentCount = 0;// 处理var getComment = function(topicUrl, callback) { connectCurrentCount++; console.log(&apos;现在的并发数是&apos;, connectCurrentCount, &apos;，正在抓取的是&apos;, topicUrl); superagent.get(topicUrl) .end(function (err, sres) { connectCurrentCount--; if(err) { getCommont(topicUrl, callback); return; } var $ = cheerio.load(sres.text); callback(null, { title: $(&apos;.topic_full_title&apos;).text().trim(), href: topicUrl, comment: $(&apos;.reply_content&apos;).eq(0).text().trim() }); });};// 访问superagent.get(cnodeUrl) .end(function(err, res) { if(err) { console.log(err); return; } var $ = cheerio.load(res.text); var urls = []; $(&apos;#topic_list .topic_title&apos;).each(function(idx, element){ var $element = $(element); urls.push(url.resolve(cnodeUrl, $element.attr(&apos;href&apos;))); }); console.log(urls); // 得到40个主题的url // 开启并发访问 async.mapLimit(urls, 5, function(topicUrl, callback){ getComment(topicUrl, callback); }, function(err, result){ console.log(&apos;final-&gt;&apos;); console.log(result); // 40次返回结果汇总为数组 }); }); 有图有真相:","link":"/2015/08/04/nodejs-lesson5/"},{"title":"Nodejs第六课","text":"测试用例: mocha, should, istanbul第六课, 原文链接Node.js-lesson6 目标建立lesson6项目,编写代码main.js: 其中有个fibonacci函数.fibonacci的介绍详见维基百科,中文名 斐波那契此函数的定义为int fibonacci(int n) 当 n === 0 时,返回0; n === 1 时,返回1 n &gt; 1 时,返回fibonacci(n) = fibonacci(n - 1) + fibonacci(n-2),如fibonacci === 55 n不能大于10,否则抛错,因为Node.js的计算性能没那么强,到此为止 n也不能小于0,否则抛错,因为没意义 n不为数字时,抛错 test/main.test.js: 对main函数进行测试,并使行覆盖率和分支覆盖率都达到100% 知识点： 学习使用测试框架 mocha 学习使用断言库 should 学习使用测试率覆盖工具 istanbul 简单Makefile的编写 课程内容$ npm init 初始化项目编辑 main.js,编写 fibonacci 函数 12345678910111213141516// file main.jsvar fibonacci = function(n) { if(n === 0) { return 0; } if(n === 1) { return 1; } return fibonacci(n-1) + fibonacci(n-2);};if(require.main === module) { // 如果是直接执行main.js,则进入此处 // 如果是main.js被其他文件require,则此处不会执行 var n = Number(process.argv[2]); console.log(&apos;fibonacci(&apos; + n + &apos; ), is&apos;, fibonacci(n));} 执行 $ node main.js 10运行 接下来开始测试驱动开发,我们先得把main.js里面的fibonacci暴露出来,这个简单加上exports.fibonacci = fobonacci;(我承认,我看不懂,我还需要补充基础知识) 然后在test/main.test.js中引用我们的main.js,开始一个简单的测试 12345678// file: test/main.test.jsvar main = require(&apos;../main&apos;);var should = require(&apos;should&apos;);describe(&apos;test/main.test.js&apos;, function () { it(&apos;should equal 55 when n === 10&apos;, function(){ main.fibonacci(10).should.equal(55); });}); 测试之前,需要使用npm install should --save安装should这个外部模块然后安装一个全局的mocha:$ sudo npm install mocha -g执行:$ mocha should模块是一个断言库,mocha和should协作完成测试should在Javascript的Object’基类’上注入了一个#should属性,这个属性又带有许许多多的属性可以访问比如测试一个数是不是大于3,则是(5).should.above(3),测试一个字符串是否有着特定的前缀:'foobar'.should.startWith('foo');,should.js APIshould.js 如果现在还是 version 3 的话,推荐大家去看看它的 API 和 源码;现在 should 是 version 4 了,API 丑得很,但为了不掉队,我还是一直用着它.我觉得 expect 麻烦,所以不用 expect,对了,expect 也是一个断言库:https://github.com/LearnBoost/expect.js/. 记得fibonacci函数的几个要求吗？ 12345* 当 n === 0 时,返回0; n === 1 时,返回1* n &gt; 1 时,返回` fibonacci(n) = fibonacci(n - 1) + fibonacci(n-2) `,如` fibonacci === 55 ` * n不能大于10,否则抛错,因为Node.js的计算性能没那么强,到此为止* n也不能小于0,否则抛错,因为没意义* n不为数字时,抛错 现在就让我们学习使用测试用例来描述一下这几个要求,更新后的main.test.js: 123456789101112131415161718192021222324252627282930313233343536// file test/main.test.jsvar main = require(&apos;../main&apos;);var should = require(&apos;should&apos;);describe(&apos;test/main.test.js&apos;, function () { it(&apos;should equal 0 when n === 0&apos;, function(){ main.fibonacci(0).should.equal(0); }); it(&apos;should equal 1 when n === 1&apos;, function(){ main.fibonacci(1).should.equal(1); }); it(&apos;should equal 55 when n === 10&apos;, function(){ main.fibonacci(10).should.equal(55); }); it(&apos;should throw when n &gt; 10&apos;, function () { (function(){ main.fibonacci(11); }).should.throw(&apos;n should &lt;= 10&apos;); }); it(&apos;should throw when n &lt; 0&apos;, function(){ (function () { main.fibonacci(-1); }).should.throw(&apos;n should &gt;= 0&apos;); }); it(&apos;should throw when n isn\\&apos;t Number&apos;, function(){ (function(){ main.fibonacci(&apos;呵呵&apos;); }).should.throw(&apos;n should be a Number&apos;); });}); 执行$ mocha,上图,没通过: 现在我们只能修改fibonacci的实现了: 12345678910111213141516171819202122232425262728// file main.jsvar fibonacci = function(n) { if(typeof n !== &apos;number&apos;) { throw new Error(&apos;n should be a Number&apos;); } if(n &lt; 0) { throw new Error(&apos;n should &gt;= 0&apos;); } if(n &gt; 10) { throw new Error(&apos;n should &lt;= 10&apos;); } if(n === 0) { return 0; } if(n === 1) { return 1; } return fibonacci(n-1) + fibonacci(n-2);};if(require.main === module) { // 如果是直接执行main.js,则进入此处 // 如果是main.js被其他文件require,则此处不会执行 var n = Number(process.argv[2]); console.log(&apos;fibonacci(&apos; + n + &apos; ), is&apos;, fibonacci(n));}exports.fibonacci = fibonacci; 再次执行$ mocha,就过了.我也是现在才知道这就是传说中的测试驱动开发:先把要达到的目的都描述清楚,然后让现有的程序跑不过case,再修补,让case通过.安装一个istanbul:$ sudo npm install istanbul -g执行$ istanbul cover _mocha会看到比直接使用mocha命令多一些输出内容,而且很生成一些文件 Branches:分支覆盖率 Statements:行覆盖率使用命令打开$ open coverage/lcov-report/index.html 其实测试的覆盖率是100%的，但是23、24这两行无法测试mocha和istanbul是无缝结合的,只要能使用mocha测试,那么就能配合istanbul测试剩下的就是需要说明版本兼容问题,程序都是向下兼容,低版本肯定跑不起高版本的一些东西 假设你有一个项目A,用到了 mocha 的 version 3,其他人有个项目B,用到了 mocha 的 version 10,那么如果你 $ sudo npm install mocha -g 装的是 version 3 的话,你用 $ mocha 是不兼容B项目的.因为 mocha 版本改变之后,很可能语法也变了,对吧. 这时，跑测试用例的正确方法，应该是: $ npm install mocha --save-dev,装个 mocha 到项目目录中去 $ ./node_modules/.bin/mocha,用刚才安装的这个特定版本的 mocha,来跑项目的测试代码. ./node_modules/.bin 这个目录下放着我们所有依赖自带的那些可执行文件(该目录为隐藏目录$ ls -a可查看) 每次输入这个很麻烦对吧?所以我们要引入 Makefile,让 Makefile 帮我们记住复杂的配置. 1234567test: ./node_modules/.bin/mochacov test-cov: ./node_modules/bin/istanbul cover _mocha.PHONY: test cov test-cov 这个时候,只需要调用$ make test或者$ make cov,就可以测试了 Makefile学习链接: http://blog.csdn.net/haoel/article/details/2886","link":"/2015/08/05/nodejs-lesson6/"},{"title":"Nodejs第七课","text":"浏览器端测试: mocha、chai、phantomjs目标 建立lesson7项目,编写代码 main.js类似第六节课中提交的fibonacci函数 此函数的定义为int fibonacci(int n) 当n === 0,返回0.n === 1时,返回1 n &gt; 1,返回fibonacci(n) === fibonacci(n-1) + fibonacci(n-2),如fibonacci(10) === 55 verdor文件:前端单元测试环境 verdor/test.js编写针对前端脚本的测试用例 知识点 学习使用测试框架mocha进行前端测试 了解全栈的断言库chai 了解headless浏览器phantomjs 前端脚本单元测试lesson6的内容都是针对后端环境中node的一些单元测试方案,出于应用健壮性的考量,针对前端js脚本的单元测试也非常重要.而前后端通吃,也是mocha的一大特点.首先,前端脚本的单元测试主要由两个困难需要解决. 运行环境在浏览器中,可以操作浏览器的DOM对象,且可以随意定义执行时的HTML上下文 测试结果应当可以直接反馈给mocha,判断测试是否可以通过 浏览器环境下执行首先搭建测试原型,执行mocha init f2e mocha就会自动生成一个简单的测试原型 123456// f2e . ├── index.html ├── mocha.css ├── mocha.js └── tests.js 其中index.html是单元测试的入口,test.js是我们的测试用例文件我们直接在index.html插入上述示例的fibonacci函数以及断言库chaijs chai模块可以随意建立一个空项目然后安装后复制使用 12$ npm init$ npm install chaijs --save 在node_modules文件夹中复制chai文件夹到f2e文件夹中 12345678// f2e . ├── index.html ├── mocha.css ├── mocha.js ├── tests.js └──chai ──...(chai模块的所有文件) index.html: 12345678910111213141516171819&lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;&lt;script src=&quot;mocha.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;chai/chai.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var fibonacci = function(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } return fibonacci(n-1) + fibonacci(n-2); };&lt;/script&gt;&lt;script&gt;mocha.setup(&apos;bdd&apos;)&lt;/script&gt;&lt;script src=&quot;tests.js&quot;&gt;&lt;/script&gt;&lt;script&gt; mocha.run();&lt;/script&gt; test.js中写入对应的测试用例 123456var should = chai.should();describe(&apos;simple test&apos;, function(){ it(&apos;should equal 0 when n === 0&apos;, function(){ window.fibonacci(0).should.equal(0); });}); 使用浏览器打开index.html,完成测试 测试反馈mocha没有提供一个命令行的前端脚本测试环境(因为我们的脚本文件需要运行在浏览器环境中),因为我们使用phanatomjs帮助我们搭建一个模拟环境.不重复造轮子,直接使用mocha-phantomjs帮助我们在命令行运行测试 安装$ sudo npm install -g mocha-phantomjs对应修改index.html: 1234&lt;script&gt; if(window.mochaPhantomJS) { mochaPhantomJS.run(); } else{ mocha.run(); }&lt;/script&gt; 运行$ mocha-phantomjs index.html查看测试结果 也可以使用另一种方案,在package.json中定义1234 &quot;script&quot;: { &quot;test&quot;: &quot;./node_modules/.bin/mocha-phantomjs index.html&quot; }} 将mocha-phantomjs作为依赖12$ npm init$ npm install mocha-phantomjs --save-dev 直接运行$ npm test 至此,我们实现了前端脚本的单元测试，基于 phanatomjs 你几乎可以调用所有的浏览器方法，而 mocha-phanatomjs 也可以很便捷地将测试结果反馈到 mocha，便于后续的持续集成。","link":"/2015/08/10/nodejs-lesson7/"},{"title":"Nodejs第八课","text":"测试用例:supertest学习中,原文链接 目标建立一个lesson8项目,在其中编写代码 app.js:其中有个fibonacci接口 fibonacci函数的定义为int fibonacci(int n),调用函数的url路径是/fib?n=10,然后这个接口会返回55函数的行为定义如下: 当n === 0时,返回0;n === 1时，返回1 n &gt; 1时,返回fibonacci(n) === fibonacci(n-1) + fibonacci(n-2),如fibonacci(10) === 55 n不可大于10,否则抛错,http status 500,因为Node.js的计算性能没那么强。 n也不可小于0,否则抛错500,因为没意义。 n不为数字时，抛错,500 test/app.test.js:对app的接口进行测试,覆盖以上所有情况 知识点 学习supertest的使用 复习mocha,should的使用 开始1$ npm init # 来吧,一阵阵的键盘声(不停的回车) 然后编写安装模块$ npm install xxx --save和$ npm install xxx --save-dev是有差异的噢,修改于配置文件中的地方不同噢 12345678&quot;devDependencies&quot;: { &quot;mocha&quot;: &quot;^1.21.4&quot;, &quot;should&quot;: &quot;^4.0.4&quot;, &quot;supertest&quot;: &quot;^0.14.0&quot;},&quot;dependencies&quot;: { &quot;express&quot;: &quot;^4.9.6&quot;} 编写代码app.js: 12345678910111213141516171819202122232425262728293031323334353637383940var express = require(&apos;express&apos;);var fibonacci = function(n) { if (typeof n !== &apos;number&apos; || isNaN(n)) { throw new Error(&apos;n should be a Number&apos;); } if (n &lt; 0) { throw new Error(&apos;n should &gt;= 0&apos;); } if (n &gt; 10) { throw new Error(&apos;n should &lt;= 10&apos;); } if (n === 0) { return 0; } if (n === 1) { return 1; } return fibonacci(n-1) + fibonacci(n-2);};var app = express();app.get(&apos;/fib&apos;, function(req, res){ var n = Number(req.query.n); try{ //如果直接给个数字的话,它会当成你给了一个http状态码,所以我们转换成String res.send(String(fibonacci(n))); } catch(e) { res.status(500) .send(e.message); }});// module.exports与exports的区别module.exports = app;app.listen(3000, function(){ console.log(&apos;app ls listening at port 3000&apos;);}); 运行$ node app.js 访问http://localhost:3000/fib?n=10,看到55就成功了.访问http://localhost:3000/fib?n=111,会看到n should &lt;= 10. 大家可以去安装一个nodemon$ npm install -g nodemon这个库是专门调试的时候使用,会自动检测Node.js代码的改动,然后帮你自动重启应用在调试时可以完全用nodemon命令代替node命令使用$ nodemon app.js启动我们的应用试试,然后添加两行输出代码,应用自动重启了 现在我们继续写完测试代码,test/app.test.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var app = require(&apos;../app&apos;);var supertest = require(&apos;supertest&apos;);//关键代码,下面的request对象可以直接按照//superagent的api进行调用var request = supertest(app);var should = require(&apos;should&apos;);describe(&apos;test/app.test.js&apos;, function(){ it(&apos;should return 55 when n is 10&apos;, function(done){ //function之所以要接受一个done函数,是因为我们的测试内容涉及了异步调用 //而mocha是无法感知异步调用完成的.所以主动接受它提供的done函数 //在测试完毕时,自行调用一下,表示结束 //mocha可以感知到我们的测试函数是否接受done参数. //js中,function对象是有长度的,长度由它的参数数量决定 //(function(a, b, c, d){}).length === 4 //所以mocha测试了函数的长度就可以确定我们是否是异步测试 request.get(&apos;/fib&apos;) //query方法用来传querystring //send方法用来传body //下面的query等于访问 /fib?n=10 .query({n: 10}) .end(function(err, res){ //http返回的是string,所以传入字符串&apos;55&apos; res.text.should.equal(&apos;55&apos;); done(err); // done(err)用法很鸡肋 // 完整写法 /* should.not.exist(err); res.text.should.equal(&apos;55&apos;); */ }); }); //由于代码基本相似,我们抽象一个testFib方法 var testFib = function(n, statusCode, expect, done) { request.get(&apos;/fib&apos;) .query({n: n}) .expect(statusCode) .end(function(err, res){ res.text.should.equal(expect); done(err); }); }; it(&apos;should return 0 when n === 0&apos;, function(done) { testFib(0, 200, &apos;0&apos;, done); }); it(&apos;should return 1 when n === 1&apos;, function(done) { testFib(1, 200, &apos;1&apos;, done); }); it(&apos;should equal 55 when n === 10&apos;, function(done) { testFib(10, 200, &apos;55&apos;, done); }); it(&apos;should throw error when n &gt; 10&apos;, function(done) { testFib(11, 500, &apos;n should &lt;= 10&apos;, done); }); it(&apos;should throw error when n &lt; 0&apos;, function(done) { testFib(-1, 500, &apos;n should &gt;= 0&apos;, done); }); //单独测试一下返回码500 it(&apos;should status 500 when error&apos;, function(done) { request.get(&apos;/fib&apos;) .query({n: 100}) .expect(500) .end(function(err, res) { done(err); }); });}); 执行$ mocha,得到结果 关于cookie持久化 1.在supertest中,通过var agent = supertest.agent(app)获取一个agent对象,这个对象的API跟直接在superagent上调用各种方法是一样的.agent对象在被多次调用get和post之后,可以一路把cookie都保存下来 1234567var supertest = require(&apos;supertest&apos;);var app = express();var agent = supertest.agent(app);agent.post(&apos;login&apos;).end(...);// do somethings ...agent.post(&apos;create_topic&apos;).end(...); // 此时的agent中有用户登录后的cookie 2.在发起请求时,调用.set('Cookie', 'a cookie string')这样的方式. 12345678var supertest = require(&apos;supertest&apos;);var userCookie;supertest.post(&apos;login&apos;).end(function(err, res) { userCookie = res.headers[&apos;Cookie&apos;];});supertest.post(&apos;create_topic&apos;) .set(&apos;Cookie&apos;, userCookie) .end(...); 这里边有非常详细的介绍,可以学习:https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js","link":"/2015/08/13/nodejs-lesson8/"},{"title":"Nodejs第九课","text":"正则表达式目标1var web_development = &quot;python php ruby javascript jsonp perhapsphpisoutdated&quot;; 找出其中包含p但不包含ph的所有单词,即[ 'python', 'javascript', 'jsonp'] 知识点 正则表达式的使用 js中正则表达式与pcre的区别 课程内容开始这门课之前,先学习正则表达式30分钟入门教程然后继续学习零宽断言正则表达式之:零宽断言不『消费』 很久以前,处理字符串领域的王者当属perl.后来出现一个标准叫pcre.不过前两个都不算标准,后来出现了正则表达式.js里的正则表达式与pcre不兼容.测试自己写的正则表达式可以访问http://refiddle.com/,所见即所得地调试 讲述js中正则表达式 js中,对于四种零宽断言,只支持零宽正预测先行断言和零宽度负预测先行断言 js中,正则表达式后面可以跟三个flag.比如/something/igm. i的意义是不区分大小写 g的意义是匹配多个 m的意义是^和$可以匹配每一行的开头 举几个例子: 123456/a/.test(&apos;A&apos;) // =&gt; false/a/i.test(&apos;A&apos;) // =&gt; true&apos;hello hell hoo&apos;.match(/h.*?\\b) // =&gt; [ &apos;hello&apos;, index: 0, input: &apos;hello hell hoo&apos; ]&apos;hello hell hoo&apos;.match(/h.*?\\b/g) // =&gt; [ &apos;hello&apos;, &apos;hell&apos;, &apos;hoo&apos; ]&apos;aaa\\nbbb\\nccc&apos;.match(/^[\\s\\S)*?$/g) // =&gt; [ &apos;aaa\\nbbb\\nccc&apos; ]&apos;aaa\\nbbb\\nccc&apos;.match(/^[\\s\\S]*?$/gm) // =&gt; [ &apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos; ] 还有一些别的: 123\\A 字符串开头(类似^,但不受处理多行选项的影响)\\Z 字符串结尾或行尾(不受处理多行选项的影响)\\z 字符串结尾(类似$,但不受处理多行选项的影响) 在js中,g flag 会影响String.prototype.match()和RegExp.prototype.exec()的行为String.prototype.match()中,返回数据的格式会不一样,加g会返回数组,不加g则返回比较详细的信息 12&apos;hello hell&apos;.match(/h(.*?)\\b/g) // =&gt; [ &apos;hello&apos;, &apos;hell&apos; ]&apos;hello hell&apos;.match(/h(.*?)\\b/) // =&gt; [ &apos;hello&apos;, &apos;ello&apos;, index: 0, input: &apos;hello hell&apos; ] RegExp.prototype.exec()中: 12345/h(.*?)\\b/g.exec(&apos;hello hell&apos;) // =&gt; [ &apos;hello&apos;, &apos;ello&apos;, index: 0, input: &apos;hello hell&apos; ]/h(.*?)\\b/g.exec(&apos;hello hell&apos;) // =&gt; [ &apos;hello&apos;, &apos;ello&apos;, index: 0, input: &apos;hello hell&apos; ]var re = /h(.*?)\\b/g;re.exec(&apos;hello hell&apos;) // =&gt; [ &apos;hello&apos;, &apos;ello&apos;, index: 0, input: &apos;hello hell&apos; ]re.exec(&apos;hello hell&apos;) // =&gt; [ &apos;hell&apos;, &apos;ell&apos;, index: 6, input: &apos;hello hell&apos; ] 第三.大家知道.是不可以匹配\\n的.如果我们想匹配的数据涉及到了跨行: 12345678910var mutiline = require(&apos;multiline&apos;);var text = multiline.stripIndent(function(){ /* head ``` code code2 .code3``` ``` foot */}); 如果需要获取两个12345678惯用写法`[\\s\\S]` ``` code var match1 = text.match(/^```[\\s\\S]+?^```/gm); console.log(match1); //这里有一种很骚的写法,[^]与[\\s\\S]等价 var match2 = text.match(/^```[^]+?^```/gm); console.log(match2); 结果: 12[ &apos;```\\ncode code2 .code3```\\n```&apos; ][ &apos;```\\ncode code2 .code3```\\n```&apos; ] 我把学习中写的代码全贴上了,自己测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var s = &apos;aaalllsss0tAAAnnn999&apos;;var re2 = /(\\w)\\1{2}(?=(\\w)\\2{2})/g;console.log(s.match(re2));var s = &apos;aaalllsss0tAAAnnn999&apos;;var re1 = /((\\w)\\2{2})(\\w)\\3{2}/g;console.log(s.match(re1));var s = &apos;aaalllsss0tAAAnnn999&apos;;var re1 = /((\\w)\\2{2})(\\w)\\3{2}/g;console.log(&quot;s is: &quot; + s);console.log();var res;while(res=re1.exec(s)) { console.log(&quot;match result: &quot; + res[1] + &quot;.&quot;, &quot;re1 comsumed: &quot; + res[0], &quot;re1.lastindex: &quot; + re1.lastIndex, &quot;remain string: &quot; + s.slice(re1.lastIndex));}var s = &apos;aaalllsss0tAAAnnn999&apos;;var re1 = /(\\w)\\1{2}(?=(\\w)\\2{2})/g;console.log(&quot;s is: &quot; + s);console.log();var res;while(res=re1.exec(s)) { console.log(&quot;match result: &quot; + res[1] + &quot;.&quot;, &quot;re1 comsumed: &quot; + res[0], &quot;re1.lastindex: &quot; + re1.lastIndex, &quot;remain string: &quot; + s.slice(re1.lastIndex));} console.log(/a/.test(&apos;A&apos;)); console.log(/a/i.test(&apos;A&apos;)); console.log(&apos;hello hell hoo&apos;.match(/h.*?\\b/)); console.log(&apos;hello hell hoo&apos;.match(/h.*?\\b/g)); console.log(&apos;aaa\\nbbb\\nccc&apos;.match(/^[\\s\\S]*?$/g)); console.log(&apos;aaa\\nbbb\\nccc&apos;.match(/^[\\s\\S]*?$/gm)); console.log(&apos;hello hell&apos;.match(/h(.*?)\\b/g)); console.log(&apos;hello hell&apos;.match(/h(.*?)\\b/)); console.log(/h(.*?)\\b/g.exec(&apos;hello hell&apos;)); console.log(/h(.*?)\\b/g.exec(&apos;hello hell&apos;)); var re = /h(.*?)\\b/g; console.log(re.exec(&apos;hello hell&apos;)); console.log(re.exec(&apos;hello hell&apos;)); var multiline = require(&apos;multiline&apos;); var text = multiline.stripIndent(function(){ /* head ``` code code2 .code3``` ``` foot */ }); var match1 = text.match(/^```[\\s\\S]+?^```/gm); console.log(match1); //这里有一种很骚的写法,[^]与[\\s\\S]等价 var match2 = text.match(/^```[^]+?^```/gm); console.log(match2); 目标答案,出自一个牛人之手,我写了好久都没写出来…-_-!!! 1234567891011var web_development = &apos;python php ruby javascript jsonp perhapsphpisoutdated&apos;;var reg1 = /\\b(?=\\w*p\\w*)(?!\\w*ph\\w*)\\w*\\b/ig;console.log(&quot;web_development is: &quot; + web_development);console.log(web_development.match(reg1));var res;while(res = reg1.exec(web_development)) { console.log(&quot;match result: &quot; + res[1] + &quot;.&quot;, &quot;reg1 comsumed: &quot; + res[0], &quot;reg1.lastindex: &quot; + reg1.lastIndex, &quot;remain string: &quot; + web_development.slice(reg1.lastIndex));}","link":"/2015/08/24/nodejs-lesson9/"},{"title":"npm express安装","text":"Windows 7 下使用nodejs的npm管理工具安装expressexpress已经将版本分离了,需要单独安装: express3:1$ npm install -g express-generator@3 express4:1$ npm install -g express-generator","link":"/2015/07/26/npm-express安装/"},{"title":"view和layer缠绵","text":"view 的 frame bounds center 要先讲解frame,还是得讲解bounds; 当一个view添加到viewcontroller.view时,其实是基于viewcontroller.view的坐标系; 就像viewcontrolelr.view添加到uiwindow,其实是基于uiwindow的坐标系; view的bounds属性就是添加子view的时候,给子视图参照的坐标系; 该坐标系是由bounds和center计算,frame只是方便描述这两个值而已 例如:1234567891011坐标系A [viewcontroller.view的bounds 坐标原点(0,0)]view.frame = (0,0, 100,100) [view在坐标系A中的坐标和大小]view.center = (50,50) [view的中心在坐标系A中的坐标]view.bounds = (0,0, 100,100) [此时坐标系B(view.bounds所计算的坐标系)和坐标系A重叠] 坐标系B.原点x = view.center.x - view.bounds.size.width/2 - view.bounds.origin.x; 坐标系B.原点y = view.center.y - view.bounds.size.height/2 - view.bounds.origin.y; 此时坐标系B的原点在坐标系A中为(0,0) 如果你不相信,再添加view1到view中,修改view.bounds.origin为(10,10),view1一定向左移,因为坐标系B的原点向左移动了,view1是基于坐标系B的 所以根据上面所分析的,得出结论: 当给view添加子view1,子view1将参考坐标系B(view.bounds和view.center所计算的坐标系) 坐标系B的坐标原点,受center的值和bounds的值的影响 bounds的值和center的值由frame计算而来,反过来center值和bounds值的改变不会影响frame frame只是便于描述点+宽高,产生一个矩形view而已,内部其实是center和bounds.size来控制view 123456frame = CGRectMake(0, 0, 100, 100);//orbounds = CGRectMake(0, 0, 100, 100);center = CGPointMake(50, 50);所以view其实是在坐标系A中确定了中点,再确定宽高,然后就看到了图形 layer 的 frame bounds position anchorPoint 我们不建议直接设置view.layer为一个新的layer的,而是采用[view addSubview]的形式添加子layer 此时子layer依然参view.bounds所产生的坐标系B 而加入anchorPoint的用意是在把layer的”中心”设置在layer的矩形具体的什么位置 (0,0)左上角, (1,1)右下角, 默认(0.5,0.5) position就是view的center 比如在桌子上订一个点,默认把矩形的中心放在这个点上,现在改变anchorPoint(改变矩形中和桌子上订点的对应点),看到的矩形的位置将会发生变化 bounds、frame与view一样,bounds会确定一个大小和坐标系,frame只是方便描述bounds和position anchorPoint(锚点)","link":"/2015/11/04/view和layer缠绵/"},{"title":"yaml语法的使用","text":"YAML语法 缩进格式均使用空格符,兼容编辑器,而没有采用TAB 官方文档 注释: 12345# Author: Yutiya# NiceYutiya: - name: Song - age: 18 # always 18,too young 序列（数组）: 123- Mark- Sammy- Ken 字典（键值对）: 123hr: 65avg: 0.278rbi: 147 字典包含序列: 12345678american: - Boston - Detroit - New Yorknational: - New York - Chicago - Atlanta 序列包含字典: 12345678- name: Mark hr: 65 avg: 0.278- name: Sammy hr: 63 avg: 0.288 序列包含序列: 123- [name, hr, avg]- [Mark, 65, 0.278]- [Sammy, 63, 0.288] 字典包含字典: 12345Mark: {hr: 65, avg: 0.278}Sammy: { hr: 63, avg: 0.288 } 结构:原文内容:YAML uses three dashes (“—”) to separate directives from document content. This also serves to signal the start of a document if no directives are present. Three dots ( “…”) indicate the end of a document without starting a new one, for use in communication channels.(大概意思是说yaml文件中可以有多个文档，以—开始,以…结束) 在一个流中有两个文档: 12345678910# Ranking of 1998 home runs---- Mark- Sammy- Ken# Team---- Chicago- St 游戏记录: 12345678time: 20:03:20player: Sammyaction: strike...---time: 20:03:47player: Sammyaction: grand 单一文档中的两个字典: 12345678---hr: # 1998 - Mark - Sammyrbi: # 1998 - Sammy - Ken 在文档中”Sammy”节点出现两次 12345678---hr: - Mark # 节点标签 - &amp;SS Sammy Sosarbi: - *ss # 子序列引用 - Ken 博客也是采用上面列出的这些基础yaml语法,其余的博主尚未理解,看官方文档吧","link":"/2015/08/04/yaml语法的使用/"},{"title":"关于163邮箱收不到github邮件","text":"在github帐号中绑定的邮箱收不到验证码的时候请在163邮箱的设置-&gt;反垃圾/黑名单 的白名单列表添加 github.com support@github.com 一般添加完后就能收到了，添加后不能收到，在github中多点击几次发送验证邮件就能收到了，网易旗下邮箱均按此设置，估计网易的反垃圾邮件机制出问题了Githuber，Happy!","link":"/2015/07/28/关于163邮箱收不到github邮件/"},{"title":"关于iOS屏幕方向让你找到存在感","text":"关于iOS屏幕方向,让你找到方向感看了这篇文章,可能是我太笨,有可能是作者太牛逼,反正我是没看懂,都没下他写的demo写的什么鬼,自己来搞一搞原文链接:http://lvwenhan.com/ios/458.html 新建一个空项目,在target-&gt;General-&gt;Deployment Info中勾选 Protrait Landscape Left Landscape Right 不然只会支持你所选择的方向(那就没得玩了)然后再Main.storyboard中拖入一个按钮,放到左上角一些,why?因为不在界面上放个东西,改变方向你会晕的现在run,手动改变方向command+⬅️,效果给你个截图 可以看到屏幕的方向会随着设备的方向而改变,Landscape Left(顺时针转,home键在左),如果用户锁定了屏幕旋转,那就不用讨论设备转向的情况下屏幕跟随转向的问题了 1234567//file ViewController.m...- (BOOL)shouldAutorotate{ return NO;}... 显而易见的,这个方法控制我们的页面是否跟随设备转动而改变方向 我们研究这个的目的是不管用户是否锁定屏幕转向,我们在打开新页面的时候,也需要手动控制viewController显示的方向现在我们新建一个SecondViewController类,往Main.storyboard中拖入一个viewController,绑定SecondViewController,Storyboard ID:secondVC写代码跳转,像这样… 加入这个代码到SecondViewController.m中,强制设置屏幕方向,不一定能通过苹果审核噢 123456789- (void)viewDidLoad { [super viewDidLoad]; if([[UIDevice currentDevice]respondsToSelector:@selector(setOrientation:)]) { [[UIDevice currentDevice]performSelector:@selector(setOrientation:) withObject:@(UIInterfaceOrientationLandscapeLeft)]; } } 时光不能倒流,回不去,对吧,呵呵,强制设置,你可以试试在退出的时候再设置回来,对吧 1234- (BOOL)shouldAutorotate{ return NO;} 如果在加入这个,呵呵,上面那段代码不是扯淡? 去掉UIDeveice的代码,继续搞… 12345678910111213141516171819//file viewController.m的代码是这样- (BOOL)shouldAutorotate{ return NO;}- (NSUInteger)supportedInterfaceOrientations{ return UIInterfaceOrientationMaskPortrait;}//file SecondViewController.m的代码是这样- (BOOL)shouldAutorotate{ return NO;}- (NSUInteger)supportedInterfaceOrientations{ return UIInterfaceOrientationMaskLandscapeLeft;} 百度了一下很多的帖子,实际写代码,不用重写以下方法,why?自我理解,因为我们是自己手动管理屏幕方向,由我们控制每个viewController的显示方向 1234- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{ return UIInterfaceOrientationLandscapeLeft;} 在我们使用的过程中,通常我们是嵌套viewController,比如N+V或者T+N+V等等在Main.storyboard中给ViewController套一个navigationControllerEditor-&gt;Embed In-&gt;Navigation Controller然后run 我们发现,viewController会跟随设备旋转了,新建一个navigationController类,在该类里控制,记住与Main.storyboard中绑定12345678910//file ViewNavigationController.m// 这是一个navigationController- (BOOL)shouldAutorotate{ return NO;}- (NSUInteger)supportedInterfaceOrientations{ return UIInterfaceOrientationMaskPortrait;} 此时的Main.storyboard: 效果: 看对了吧,此时不管你有没有注释ViewController中的代码，都不会有问题TabBarController也一样所以这个就好理解了吧…,下面的是swift代码,你看不懂?抱歉,我不怎么会,能看懂 1234567891011121314// tabbarControllerfunc tabBarControllerSupportedInterfaceOrientations(tabBarController: UITabBarController) -&gt; UIInterfaceOrientationMask { return self.selectedViewController!.supportedInterfaceOrientations()}func tabBarControllerPreferredInterfaceOrientationForPresentation() -&gt; UIInterfaceOrientation { return self.selectedViewController!.preferredInterfaceOrientationForPresentation()}// navigationControlleroverride func supportedInterfaceOrientations() -&gt; UIInterfaceOrientationMask { return self.visibleViewController!.supportedInterfaceOrientations()}override func preferredInterfaceOrientationForPresentation() -&gt; UIInterfaceOrientation { return self.visibleViewController!.preferredInterfaceOrientationForPresentation()} 总结一下. 设备的方向和状态栏所在的位置不一样噢(这个知道,不过忘记了) viewController是否支持自动旋转是由自身控制 如果嵌套的话由父viewCotroller来控制","link":"/2015/08/19/关于iOS屏幕方向让你找到存在感/"},{"title":"无法编译AngulayJS源码","text":"无法编译AngulayJS源码找到./lib/versions/versions-info.js文件并找到getBuild()函数并修改 1234567function getBuild() { var hash = shell.exec(&apos;git rev-parse --short HEAD&apos;, {silent: true}).output.replace(&apos;\\n&apos;, &apos;&apos;); if (hash.code === 0) { // just check code answer as in other places return &apos;sha.&apos;+hash; } return &apos;&apos;;} 安装npm install -g grunt-cli 运行grunt自动编译","link":"/2015/09/10/无法编译AngulayJS源码/"},{"title":"正则表达式的理解和使用","text":"正则表达式正则表达式:一个字符处理标准,指令一段正则表达式字符串,用来检索、替换那个符合正则表达式的文本.http://tool.oschina.net/regex 提供在线测试 元字符 元字符 说明 匹配字符 匹配数量 \\b 匹配一个位置,单词的开头或结尾 V . 匹配除了换行符以外的一个任意字符 V \\d 匹配一个数字 V \\s 匹配任意的空白符,包括空格、制表符、换行符、中文全角空格等 V \\w 字母、数字、下划线或汉字 V ^ 匹配字符串的开始 V $ 匹配字符串的结束 V \\ 如果需要查找元字符本身,请使用字符转义,例如\\..\\\\.\\* V * 匹配字符可以重复任意次数 V + 匹配字符一次或更多次 V ? 匹配字符零次或一次 V {n} 匹配字符n次 V {n,} 匹配字符n次货更多次 V {x,y} 匹配至少x次,最多y次字符 V [aeiou] 匹配aeiou中的任一字符 V 通过正则表达式字符串的格式为 元字符 匹配数量、字符 匹配数量或匹配字符 匹配数量注意:’(‘和’)’都是元字符,单独在正则表达式中使用元字符只会匹配一次 学习完上面的正则表达式,我们可以写出这样复杂的表达式1\\(?0\\d{2}[)-]?\\d{8} 可以匹配(010-88886666)这样的电话号码 分支不过刚才的正则表达式在某些情况下也会出现错误,比如010)11112222或(010-33334444这或许是我们不想看到的,所以我们需要在适当的时候选择分支条件采用|把不同的规则分开比如:0\\d{2}-\\d{8}|0\\d{3}-\\d{7}可以匹配三位区号8位本地号和4位区号7为本地号我们来改写一下上面的匹配电话号码的,以3位区号为例:\\(?0\\d{2}\\)?[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}匹配3位区号,本地号码为8位的,注意-后有一个空格,若中间必须有一个-,可直接写-,也可单独直接写空格 分组在前面我们知道怎么重复单个字符,如果需要重复多个字符就会用到分组(\\d{1,3}).){3}\\d{1,3}是一个简单的IP地址匹配,不完全正确,我们来展开\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1.3},第一个分组重复3次,再与后面相连为什么说不完全正确.0.0.0.0或256.256.256.256这些不满足条件的IP地址这一次我们慢慢来写: 2[0-4]\\d|25[0-5]|[01]?\\d\\d?匹配0~255 ((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}匹配前面的255.255.255. 剩下的就能搞定了吧 反义取匹配的反义,比如匹配除了数字以外的字符 元字符 说明 匹配字符 匹配数量 \\W 匹配任一不是字母、数字、下划线和汉字的字符 V \\S 匹配任意不是空白符的字符 V \\D 匹配任意不是数字的字符 V \\B 匹配不是单词开头或结束的位置 V [^x] 匹配除了x以外的任一字符 V [^aeiou] 匹配除了aeiou这几个字母以外的任一字符 V &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串 后向引用我们在前面的分组中使用了()来匹配文本,()内的内容为一个子表达式,默认情况下,每一个分组都拥有一个组号,从左向右,以1开始,自动递增例如:\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词go go或kitty kitty,其中的\\1代表第一个分组中的正则表达式也自己设置分组的组名,请使用(?&lt;word&gt;\\w+)这样的语法,组名被指定为word了,或者这样(?'word'\\w+).当需要引用这个分组匹配的内容时,你可以使用\\k&lt;word&gt;.所以上一个例子也可以写成\\b(?&lt;myWord&gt;\\w+)\\b\\s+\\k&lt;myWord&gt;\\b. 常用分组语法: 分类 语法 说明 匹配 (exp) 匹配exp,并捕获文本到自动命令的组里 - (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里,或者写成(?'name'exp) - (?:exp) 匹配exp,不捕获匹配的文本,也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 - (?&lt;=exp) 匹配exp后面的位置 - (?!exp) 匹配后面跟的不是exp的位置 - (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 提供注释让人阅读 (?:exp)不会改变正则表达式的处理方式,只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面,也不会拥有组号,有时候或许你真的需要 零宽断言用于查找某些内容之前或之后的东西,也就是说它们像\\b,^,$那样用于指定一个位置,这个位置应该满足一定的条件(即断言),因此它们也被成为零宽断言. (?=exp)也叫零宽度正预测先行断言,它断言自身出现的位置的后面能匹配到表达式exp.比如:\\b\\w+(?=ing\\b),匹配以ing结尾的单词的前面部分(除了ing以外的部分),I'm singing while you're dancing,匹配到sing、danc. (?&lt;=exp)也叫零宽度正回顾后发断言,它断言自身出现的位置的前面能匹配到表达式exp.比如(?&lt;=\\bre)\\w+\\b会匹配一个以re开头的单词的后半部分(不包含re),recording code for developer,匹配到cording. ((?&lt;=\\d)\\d{3})+\\b可以给很长的数字中每三位间加一个逗号 (?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字 使用网页测试工具测试发现,(?&lt;=exp)走不通,OC测试正确 负向零宽断言前面提到过怎么查找不是某个字符或不在某个字符串里的字符的方法.但是如果我们只是想要确保某个字符没有出现,但并不像去匹配它时怎么办?例如,我们找查找单词,里面出现了字母q,但是q后面跟的不是字母u,我们可以这样写:\\b\\w*q[^u]\\w*\\b.但是这样做并不完全正确,比如benq也会匹配到或者xxxq goging.这个时候我们就可以使用负向零宽断言来匹配,因为只匹配位置.不捕获字符.\\b\\w*q(?!u)\\w*\\b零宽度负预测先行断言(?!exp),断言此位置的后面不能匹配表达式exp.比如:\\d{3}(?!\\d)匹配三位数字,而且这三位数字的后面不能是数字,\\b((?!abc)\\w)+\\b匹配不含连续字符abc的单词同理,我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的后面不能匹配表达式exp.比如:(?&lt;![a-z]\\d{7})匹配前面不是小写字母的七位数字.来一个更复杂的比如:(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;),来看看(?&lt;=&lt;(\\w)&gt;)匹配&lt;a&gt;这样开始,.*中间包含任何内容,(?=&lt;\\/\\1&gt;匹配&lt;\\a&gt;这样的,\\1反向引用,\\w前后一致,相当于匹配简单的html标签内容. 注释大概可以写成这样: 1234567(?&lt;= # 断言要匹配的文本的前缀 &lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 .* # 匹配任意文本 (?= # 断言要匹配的文本的后缀 &lt;\\/\\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签 ) # 后缀结束 贪婪与懒惰当正则表达式中包含能接收重复的元字符时,通常在使整个表达式能匹配到的前提下尽可能匹配多的字符.以这样的表达式为例:a.*b,它能匹配最长的以a开始,以b结束的字符串.如果用来搜索aabaab的话,他会匹配整个字符串aabaab.这被称为贪婪匹配.有时候我们希望懒惰匹配,匹配更少的字符,这样得到的结果可能会更多.我们可以在重复的元字符后添加?.像这样a.*?b,这样就意味着匹配任意数量的重复,但是在能使整个匹配成功的前提下使用最少的字符.我们得到的结果会是aab aab,字符更少,但可能结果会更多. 代码/语法 说明 *? 重复任意次数,尽可能少重复 +? 重复1次或更多次,尽可能少重复 ?? 重复0次或更多次,尽可能少重复 {n,m}? 重复n到m此,尽可能少重复 {n,}? 重复n次或更多次,尽可能少重复 特殊的元字符 代码/语法 说明 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符.比如\\cC代表Ctrl+C \\A 字符串开头(类似^.但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$.但不受处理多行选项的影响) \\G 当前搜索的开头 \\p{name} Unicode中命名为name的字符类.例如\\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?-exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes no) 把exp当作零宽正向先行断言,如果在这个位置能匹配,使用yes作为此组的表达式;否则使用no (?(exp)yes) 同上,只是使用空表达式作为no (?(name)yes no) 如果命名为name的组捕获到了内容,使用yes作为表达式;否则使用no (?(name)yes) 同上,只是使用空表达式作为no","link":"/2015/08/20/正则表达式的理解和使用/"},{"title":"百度地图SDK之引擎初始化失败","text":"百度地图引擎初始化失败百度地图升级了SDK,库文件编程了framework.可以看到Resources文件夹下有mapppi.bundle. 将framework拖入工程,你会发现工程能运行,地图也能出来,可是突然某一天你发现地图就不显示了.在官方文档中讲述了需要引入mapapi.bundle,那为何将该文件打包至framework中?你能想象,之前能运行,结果后来一直报内存泄露的错误,最终只是因为这个bundle文件没有加入工程吗? 引以为戒","link":"/2015/09/09/百度地图SDK引擎初始化失败/"}],"tags":[{"name":"const","slug":"const","link":"/tags/const/"},{"name":"HelloWorld","slug":"HelloWorld","link":"/tags/HelloWorld/"},{"name":"数组名","slug":"数组名","link":"/tags/数组名/"},{"name":"FFmpeg","slug":"FFmpeg","link":"/tags/FFmpeg/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","link":"/tags/ReactiveCocoa/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"exports","slug":"exports","link":"/tags/exports/"},{"name":"hadoop","slug":"hadoop","link":"/tags/hadoop/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"URLencode","slug":"URLencode","link":"/tags/URLencode/"},{"name":"UIDynamic","slug":"UIDynamic","link":"/tags/UIDynamic/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"lesson","slug":"lesson","link":"/tags/lesson/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"view","slug":"view","link":"/tags/view/"},{"name":"yaml","slug":"yaml","link":"/tags/yaml/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"orientation","slug":"orientation","link":"/tags/orientation/"},{"name":"AngularJS","slug":"AngularJS","link":"/tags/AngularJS/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"百度地图","slug":"百度地图","link":"/tags/百度地图/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"},{"name":"FFmpeg","slug":"FFmpeg","link":"/categories/FFmpeg/"},{"name":"const","slug":"C/const","link":"/categories/C/const/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"HelloWorld","slug":"C/HelloWorld","link":"/categories/C/HelloWorld/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"swift","slug":"swift","link":"/categories/swift/"},{"name":"数组名","slug":"C/数组名","link":"/categories/C/数组名/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"iOS","slug":"FFmpeg/iOS","link":"/categories/FFmpeg/iOS/"},{"name":"Shell","slug":"Shell","link":"/categories/Shell/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Socket","slug":"Java/Socket","link":"/categories/Java/Socket/"},{"name":"NSUrlSession","slug":"iOS/NSUrlSession","link":"/categories/iOS/NSUrlSession/"},{"name":"lesson","slug":"swift/lesson","link":"/categories/swift/lesson/"},{"name":"ReactiveCocoa","slug":"iOS/ReactiveCocoa","link":"/categories/iOS/ReactiveCocoa/"},{"name":"study","slug":"Redis/study","link":"/categories/Redis/study/"},{"name":"build","slug":"FFmpeg/iOS/build","link":"/categories/FFmpeg/iOS/build/"},{"name":"course","slug":"Shell/course","link":"/categories/Shell/course/"},{"name":"view","slug":"iOS/view","link":"/categories/iOS/view/"},{"name":"yaml","slug":"yaml","link":"/categories/yaml/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"orientation","slug":"iOS/orientation","link":"/categories/iOS/orientation/"},{"name":"exports","slug":"nodejs/exports","link":"/categories/nodejs/exports/"},{"name":"AngularJS","slug":"AngularJS","link":"/categories/AngularJS/"},{"name":"正则表达式","slug":"正则表达式","link":"/categories/正则表达式/"},{"name":"Hadoop","slug":"java/Hadoop","link":"/categories/java/Hadoop/"},{"name":"百度地图SDK","slug":"百度地图SDK","link":"/categories/百度地图SDK/"},{"name":"HelloWorld","slug":"Hexo/HelloWorld","link":"/categories/Hexo/HelloWorld/"},{"name":"Bug","slug":"Hexo/Bug","link":"/categories/Hexo/Bug/"},{"name":"URLencode","slug":"iOS/URLencode","link":"/categories/iOS/URLencode/"},{"name":"UIDynamic","slug":"iOS/UIDynamic","link":"/categories/iOS/UIDynamic/"},{"name":"icarus","slug":"Hexo/icarus","link":"/categories/Hexo/icarus/"},{"name":"maven","slug":"java/maven","link":"/categories/java/maven/"},{"name":"lesson","slug":"nodejs/lesson","link":"/categories/nodejs/lesson/"},{"name":"npm","slug":"nodejs/npm","link":"/categories/nodejs/npm/"},{"name":"build","slug":"AngularJS/build","link":"/categories/AngularJS/build/"},{"name":"bug","slug":"百度地图SDK/bug","link":"/categories/百度地图SDK/bug/"}]}